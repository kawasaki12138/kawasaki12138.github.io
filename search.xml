<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的leetcode</title>
      <link href="/2022/04/14/leetcode/"/>
      <url>/2022/04/14/leetcode/</url>
      
        <content type="html"><![CDATA[<p>郝斌老师：对于一个题目而言，有时候我们一写写上十几分钟一个小时就解来了；但是大多数时候，我们想了很久也没法解出问题，这个时候我们会备受打击。其实，写不出算法其实是正常的事情，包括那些大佬。学习算法，关键在于理解那些算法，学习算法的方法，应该先观察算法，算法流程 -&gt;每一部分功能 -&gt;自己试数，最后再尝试自己解决问题<span id="more"></span></p><h1 id="数组-amp-双指针"><a href="#数组-amp-双指针" class="headerlink" title="数组&amp;双指针"></a><strong>数组&amp;双指针</strong></h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解法：暴力破解</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j;<br>    <span class="hljs-keyword">int</span> *temp=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++)&#123;<br>            <span class="hljs-keyword">if</span>( nums[i] + nums[j] == target)&#123;<br>                temp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">2</span>);<br>                temp[<span class="hljs-number">0</span>]=i;<br>                temp[<span class="hljs-number">1</span>]=j;<br>                *returnSize = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">//参考答案：哈希表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span> &#123;</span><br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> val;<br>    UT_hash_handle hh;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">hashtable</span>;</span><span class="hljs-comment">//这个貌似是必须先行定义，没法在函数中定义一个头</span><br><span class="hljs-comment">//这个指针对于uthash宏操作都需要是可见的，并且指针值会被修改，通常为全局变量。</span><br><br><span class="hljs-function">struct hashTable* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ikey)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span>;</span><br>    HASH_FIND_INT(hashtable, &amp;ikey, tmp);<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ikey, <span class="hljs-keyword">int</span> ival)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(ikey);<br>    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">NULL</span>) &#123;                                 <span class="hljs-comment">//若ikey没有，则插入</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct hashTable));<br>        tmp-&gt;key = ikey, tmp-&gt;val = ival;<br>        HASH_ADD_INT(hashtable, key, tmp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;                                           <span class="hljs-comment">//若有则覆盖val的值</span><br>        it-&gt;val = ival;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//流程如下：当输入num[0]=2时，先查找hash表中target-nums[0]=7的项目是否为空</span><br><span class="hljs-comment">//若为空，则插入项目key=2，val=0；</span><br><span class="hljs-comment">//若项目不为空，则输出找到的那个项目的val同时输出i即可</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>* returnSize)</span> </span>&#123;<br>    hashtable = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(target - nums[i]);   <span class="hljs-comment">//每次查找key为target - nums[i]的项目是否为空</span><br>        <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">NULL</span>) &#123;                                <span class="hljs-comment">//若it为空，则在key为nums[i]的地方插入value:i</span><br>            <span class="hljs-keyword">int</span>* ret = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">2</span>);          <span class="hljs-comment">//否则查询成功</span><br>            ret[<span class="hljs-number">0</span>] = it-&gt;val, ret[<span class="hljs-number">1</span>] = i;<br>            *returnSize = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        insert(nums[i], i);<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的测试版本</span><br><span class="hljs-comment">//整了半天发现是要先行定义全局变量，否则没法用</span><br><span class="hljs-comment">//uthash具体使用方法：https://www.cnblogs.com/dongxb/p/14212531.html</span><br><span class="hljs-comment">//tmd，同一个测试样例，在leetcode上测试通过，但是提交的时候出错了</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;uthash.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span> &#123;</span><br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> val;<br>    UT_hash_handle hh;<br>&#125;hashtable,* hashlist;<br><br>hashlist hashhead=<span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_users</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">hashlist <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iskey)</span></span>&#123;<br>    hashlist s=<span class="hljs-literal">NULL</span>;<br>    HASH_FIND_INT(hashhead,&amp;iskey,s);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iskey,<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    hashlist s=<span class="hljs-literal">NULL</span>;<br>    s=find( iskey);<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>)&#123;<br>        hashlist temp=(hashlist)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashtable));<br>        temp-&gt;key=iskey;<br>        temp-&gt;val=num;<br>        HASH_ADD_INT( hashhead, key , temp );<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        s-&gt;val=num;<br>    &#125;<br>    print_users();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;insert\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_users</span><span class="hljs-params">()</span> </span>&#123;<br>    hashlist s;<br>    <span class="hljs-keyword">for</span>(s=hashhead; s != <span class="hljs-literal">NULL</span>; s=(hashlist)(s-&gt;hh.next)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;user id %d: name %d\n&quot;</span>, s-&gt;key, s-&gt;val);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> nums[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-keyword">int</span> numsSize=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> target=<span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">int</span> returnSize;<br>    <span class="hljs-keyword">int</span> *result=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in\n&quot;</span>);<br>        hashlist temp=find(target-nums[i]);<br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>            result=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">2</span>);<br>            result[<span class="hljs-number">0</span>]=temp-&gt;val;<br>            result[<span class="hljs-number">1</span>]=i;<br>            returnSize=<span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            insert(nums[i],i);<br><br>        &#125;<br>    &#125;<br>    returnSize=<span class="hljs-number">0</span>;<br>    print_users();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], nums2 = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 (<span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的方法：归并排序，直接查找</span><br><span class="hljs-comment">//算法时间复杂度：o(m+n)</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums1, <span class="hljs-keyword">int</span> nums1Size, <span class="hljs-keyword">int</span>* nums2, <span class="hljs-keyword">int</span> nums2Size)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> *temp=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*(nums1Size + nums2Size));<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(j&lt;nums1Size&amp;&amp;k&lt;nums2Size)&#123;<br>        <span class="hljs-keyword">if</span>(nums1[j]&lt;nums2[k])&#123;<br>            temp[i]=nums1[j];<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp[i]=nums2[k];<br>            i++;<br>            k++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;nums1Size)&#123;<br>        temp[i]=nums1[j];<br>        i++;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(k&lt;nums2Size)&#123;<br>        temp[i]=nums2[k];<br>         i++;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((nums1Size + nums2Size)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(temp[(nums1Size + nums2Size)/<span class="hljs-number">2</span>] + temp[(nums1Size + nums2Size)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>])/<span class="hljs-number">2.0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)temp[(nums1Size + nums2Size)/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>]<br>输出：[[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br><br>输入：nums = []<br>输出：[]<br><br>输入：nums = [<span class="hljs-number">0</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//我的解法：三级循环 时间复杂度：o（n^3)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    nums.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<span class="hljs-keyword">return</span> a-b&#125;);<br>    numsSize=nums.length;<br>    <span class="hljs-keyword">var</span> myArray=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>    <span class="hljs-keyword">var</span> length=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;numsSize-<span class="hljs-number">2</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span> &amp;&amp; nums[i]===nums[i-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize-<span class="hljs-number">1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j!=i+<span class="hljs-number">1</span> &amp;&amp; nums[j]===nums[j-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k=j+<span class="hljs-number">1</span>;k&lt;numsSize;k++)&#123;<br>                <span class="hljs-keyword">if</span>(k!=j+<span class="hljs-number">1</span> &amp;&amp; nums[k]===nums[k-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[j]+nums[k]==<span class="hljs-number">0</span>)&#123;<br>                    myArray[length]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);<br>                    myArray[length][<span class="hljs-number">0</span>]=nums[i];<br>                    myArray[length][<span class="hljs-number">1</span>]=nums[j];<br>                    myArray[length][<span class="hljs-number">2</span>]=nums[k];<br>                    length++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> myArray;<br>&#125;;<br><br><span class="hljs-comment">//参考答案：双指针</span><br><span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br>  <span class="hljs-comment">// 从小到大排序</span><br>  <span class="hljs-keyword">const</span> arr = nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a-b);<br>  <span class="hljs-comment">// 最小值大于 0 或者 最大值小于 0，说明没有无效答案</span><br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> || arr[arr.length - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br>  <span class="hljs-keyword">const</span> n = arr.length;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-comment">// 如果当前值大于 0，和右侧的值再怎么加也不会等于 0，所以直接退出</span><br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 当前循环的值和上次循环的一样，就跳过，避免重复值</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; arr[i] === arr[i - <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 双指针</span><br>    <span class="hljs-comment">//一共有2个指针l,r分别指向i+1和n-1，当sum(arr[i]+arr[l]+arr[r])&lt;0时，l++</span><br>    <span class="hljs-comment">//否则r--，直到二者相遇、遇到sum(arr[i]+arr[l]+arr[r])==0时，记录</span><br>    <span class="hljs-comment">//重复跳过</span><br>    <span class="hljs-keyword">let</span> l = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>      <span class="hljs-keyword">const</span> temp = arr[i] + arr[l] + arr[r];<br>      <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<br>        r --;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span>) &#123;<br>        l ++;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (temp === <span class="hljs-number">0</span>) &#123;<br>        res.push([nums[i], nums[l], nums[r]]);<br>        <span class="hljs-comment">// 跳过重复值</span><br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[l + <span class="hljs-number">1</span>]) &#123;<br>          l ++;<br>        &#125;<br>        <span class="hljs-comment">// 同上</span><br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[r - <span class="hljs-number">1</span>]) &#123;<br>          r --;<br>        &#125;<br>        l ++;<br>        r --;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">执行用时：<span class="hljs-number">9596</span> ms, 在所有 JavaScript 提交中击败了<span class="hljs-number">4.99</span><span class="hljs-comment">% 的用户</span><br>内存消耗：<span class="hljs-number">48.8</span> MB, 在所有 JavaScript 提交中击败了<span class="hljs-number">90.26</span><span class="hljs-comment">% 的用户</span><br></code></pre></td></tr></table></figure><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。必须在不使用库的sort函数的情况下解决这个问题。</p><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-comment">[0,0,1,1,2,2]</span><br><br>输入：nums = <span class="hljs-comment">[2,0,1]</span><br>输出：<span class="hljs-comment">[0,1,2]</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>你可以不使用代码库中的排序函数来解决这道题吗？</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//我的解法：两次遍历</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortColors = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> numa=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> numb=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> numc=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)&#123;<br>            numa++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">1</span>)&#123;<br>            numb++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">2</span>)&#123;<br>            numc++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(numa)&#123;<br>        nums[i]=<span class="hljs-number">0</span>;<br>        i++;<br>        numa--;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(numb)&#123;<br>        nums[i]=<span class="hljs-number">1</span>;<br>        i++;<br>        numb--;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(numc)&#123;<br>        nums[i]=<span class="hljs-number">2</span>;<br>        i++;<br>        numc--;<br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-comment">//网友答案：一次遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">sortColors</span>(<span class="hljs-params">int[] nums</span>)</span> &#123;<br>        int num0 = <span class="hljs-number">0</span>, num1 = <span class="hljs-number">0</span>, num2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//遇到0时，所有排好序的数组推一格</span><br>                nums[num2++] = <span class="hljs-number">2</span>;<br>                nums[num1++] = <span class="hljs-number">1</span>;<br>                nums[num0++] = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//遇到1时，1和2向前推一格</span><br>                nums[num2++] = <span class="hljs-number">2</span>;<br>                nums[num1++] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">//遇到2时，2向前推一格</span><br>                nums[num2++] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">执行用时：<span class="hljs-number">64</span> ms, 在所有 JavaScript 提交中击败了<span class="hljs-number">54.46</span><span class="hljs-comment">%的用户</span><br>内存消耗：<span class="hljs-number">41.1</span> MB, 在所有 JavaScript 提交中击败了<span class="hljs-number">59.27</span><span class="hljs-comment">%的用户</span><br></code></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 </p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>解法：最小覆盖串</p><p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br><br>输入：s = <span class="hljs-string">&quot;a&quot;</span>, t = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br><br>输入: s = <span class="hljs-string">&quot;a&quot;</span>, t = <span class="hljs-string">&quot;aa&quot;</span><br>输出: <span class="hljs-string">&quot;&quot;</span><br>解释: t 中两个字符 <span class="hljs-string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//参考答案</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">100000</span>, maxStartIndex = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> needWhich = &#123;&#125;; <span class="hljs-comment">// 这里存 t 子串中各字符的数量，即需要满足的个数</span><br>    <span class="hljs-keyword">let</span> windowAll = &#123;&#125;; <span class="hljs-comment">// 这里存滑动窗口遍历过程中，处于滑动窗口内部的 t 中的字符</span><br>    <span class="hljs-comment">// 初始化 needWhich，总共需要哪些字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> t) &#123;<br>        needWhich[val] = (needWhich[val] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = s.length, nowSatisfy = <span class="hljs-number">0</span>; <span class="hljs-comment">// 要多少个键值对满足 needWhich 中的才算覆盖</span><br>    <span class="hljs-keyword">while</span>(right &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> key = s[right]; <span class="hljs-comment">// 右指针当前遍历到的字符</span><br>        right++;<br><br>        <span class="hljs-comment">// 如果是 t 字符串中字符</span><br>        <span class="hljs-keyword">if</span>(needWhich[key]) &#123;<br>            windowAll[key] = (windowAll[key] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前滑动窗口的该键，值 + 1</span><br>            <span class="hljs-comment">// 如果读取到这个字符后，该字符总数 === 覆盖的子串中的该字符总数了，那就总数 + 1</span><br>            <span class="hljs-keyword">if</span>(windowAll[key] === needWhich[key]) &#123;<br>                nowSatisfy++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 当验证数量与需要的字符个数一致时，说明是覆盖子串了，接下来要找最小的也就是应该收缩窗口了</span><br>        <span class="hljs-keyword">while</span>(nowSatisfy === <span class="hljs-built_in">Object</span>.keys(needWhich).length) &#123;<br>            <span class="hljs-comment">// 更新最小覆盖子串</span><br>            <span class="hljs-keyword">if</span> (right - left &lt; maxLength) &#123;<br>                maxStartIndex = left;<br>                maxLength = right - left;<br>            &#125;<br>            <span class="hljs-comment">//即将移出窗口的字符</span><br>            <span class="hljs-keyword">const</span> outKey = s[left];<br>            <span class="hljs-comment">// 窗口左边界右移</span><br>            left++;<br>            <span class="hljs-comment">// 如果是 t 字符串中字符</span><br>            <span class="hljs-keyword">if</span>(needWhich[outKey]) &#123;<br>                <span class="hljs-comment">// 对于要移出窗口的这个字符的个数，如果 窗口内部 和 t 中的相同，即没有多余，那么 nowSatisfy--，开始找下一滑动窗口了，否则还得继续移除该字符</span><br>                <span class="hljs-keyword">if</span> (windowAll[outKey] === needWhich[outKey]) &#123;<br>                    nowSatisfy--;<br>                &#125;<br>                windowAll[outKey]--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxStartIndex === -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.slice(maxStartIndex, maxStartIndex + maxLength);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II "></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II </a></h2><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>example1:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span><br>输出：返回索引为 <span class="hljs-number">1</span> 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p>example2:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>], pos = <span class="hljs-number">-1</span><br>输出：返回 null<br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解答：暴力破解，每次查找数组中是否存在此地址，不存在则在数组中存入此地址</span><br><span class="hljs-comment">//直到链表指针域为NULL或出现在数组中</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(struct ListNode *head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> **<span class="hljs-title">temp</span>=</span>(struct ListNode **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode *)*<span class="hljs-number">10001</span>);<br>    temp[<span class="hljs-number">0</span>]=head;<br>    <span class="hljs-keyword">int</span> length=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(temp[i]==p-&gt;next)<br>                <span class="hljs-keyword">return</span> temp[i];<br>        &#125;<br>        temp[length++]=p-&gt;next;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">124</span> ms, 在所有 C 提交中击败了<span class="hljs-number">5.49</span>%的用户<br>内存消耗：<span class="hljs-number">7.5</span> MB, 在所有 C 提交中击败了<span class="hljs-number">5.95</span>%的用户<br></code></pre></td></tr></table></figure><p><strong>参考答案：快慢指针</strong></p><p>思路与算法</p><p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为<br>$$<br>a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc<br>$$<br>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 22 倍。因此，我们有<br>$$<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br>$$<br>有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参考答案</span><br><span class="hljs-function">struct ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span> =</span> head, *fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) &#123;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">ptr</span> =</span> head;<br>            <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                ptr = ptr-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//我的新解</span><br><span class="hljs-function">struct ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(struct ListNode *head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">fast</span>=</span>head;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span> || slow-&gt;next==<span class="hljs-literal">NULL</span> ||fast-&gt;next-&gt;next==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span> &amp;&amp; slow!=<span class="hljs-literal">NULL</span>)&#123;<br>        slow=slow-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//小心！如果不写这个if语句可能导致</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;           <span class="hljs-comment">//fast=fast-&gt;next-&gt;next报错</span><br>        &#125;<br>        fast=fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span>(slow==fast &amp;&amp; slow!=<span class="hljs-literal">NULL</span> &amp;&amp; fast!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p</span>=</span>head;<br>            <span class="hljs-keyword">while</span>(p!=slow)&#123;<br>                p=p-&gt;next;<br>                slow=slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点数目在范围[1, 105] 内</li><li>0 &lt;= Node.val &lt;= 9</li></ul><p>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//我的解法：头尾指针</span><br><span class="hljs-comment">//我的其他想法：栈，空间复杂度减半，但是要多遍历一回，数量级不变</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(struct ListNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> *temp=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">100001</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rear</span>=</span>head;<br>    <span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(rear!=<span class="hljs-literal">NULL</span>)&#123;<br>        temp[len++]=rear-&gt;val;<br>        rear=rear-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j=len<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(;i&lt;len/<span class="hljs-number">2</span>;i++,j--)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i]!=temp[j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参考答案：快慢指针，快指针走完的时候慢指针刚好跑一半，然后将后半/前半反转</span><br><span class="hljs-comment">//最后判断是否相等</span><br><br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;  <span class="hljs-comment">//背下来算了。。。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">prev</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">curr</span> =</span> head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">nextTemp</span> =</span> curr-&gt;next;<br>        curr-&gt;next = prev;<br>        prev = curr;<br>        curr = nextTemp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到前半部分链表的尾节点并反转后半部分链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">firstHalfEnd</span> =</span> endOfFirstHalf(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">secondHalfStart</span> =</span> reverseList(firstHalfEnd-&gt;next);<br><br>    <span class="hljs-comment">// 判断是否回文</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p1</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p2</span> =</span> secondHalfStart;<br>    <span class="hljs-keyword">bool</span> result = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (result &amp;&amp; p2 != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;<br>            result = <span class="hljs-literal">false</span>;<br>        &#125;<br>        p1 = p1-&gt;next;<br>        p2 = p2-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 还原链表并返回结果</span><br>    firstHalfEnd-&gt;next = reverseList(secondHalfStart);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入: nums = [<span class="hljs-number">0</span>]<br>输出: [<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解法：同颜色分类</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num1=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num0=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">if</span>(numsSize==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)&#123;<br>            temp=nums[i];<br>            nums[num0++]=<span class="hljs-number">0</span>;<br>            nums[num1++]=temp;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            nums[num0++]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">76</span> ms, 在所有 C 提交中击败了<span class="hljs-number">77.79</span>%的用户<br>内存消耗：<span class="hljs-number">14.8</span> MB, 在所有 C 提交中击败了<span class="hljs-number">41.01</span>%的用户<br></code></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h1><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>], n = <span class="hljs-number">1</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], n = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的题解：快慢表（伪）</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(struct ListNode* head, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rear</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">point</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span>head;<br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(count!=n)&#123;<br>        count++;<br>        rear=rear-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(rear-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        pre=point;<br>        rear=rear-&gt;next;<br>        point=point-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(point==head)&#123;<br>        head=head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        pre-&gt;next=point-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">4</span> ms, 在所有 C 提交中击败了<span class="hljs-number">52.54</span>%的用户<br>内存消耗：<span class="hljs-number">5.6</span> MB, 在所有 C 提交中击败了<span class="hljs-number">76.74</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//拓展：栈</span><br><span class="hljs-comment">//我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 </span><br><span class="hljs-comment">//nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删</span><br><span class="hljs-comment">//除操作就变得十分方便了。</span><br><span class="hljs-comment">//亲测没我的快 :)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">val</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(struct ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">dummy</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode));<br>    dummy-&gt;val = <span class="hljs-number">0</span>, dummy-&gt;next = head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">stk</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span> =</span> dummy;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">tmp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Stack));<br>        tmp-&gt;val = cur, tmp-&gt;next = stk;<br>        stk = tmp;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">tmp</span> =</span> stk-&gt;next;<br>        <span class="hljs-built_in">free</span>(stk);<br>        stk = tmp;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">prev</span> =</span> stk-&gt;val;<br>    prev-&gt;next = prev-&gt;next-&gt;next;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">ans</span> =</span> dummy-&gt;next;<br>    <span class="hljs-built_in">free</span>(dummy);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOTE:Linear_Algebra</title>
      <link href="/2022/03/07/linear-algebra/"/>
      <url>/2022/03/07/linear-algebra/</url>
      
        <content type="html"><![CDATA[<p>这是一份关于MIT 18.06的线性代数笔记，同时包含配套英文教材《introduction to linear algebra》，这份笔记记载了从第三章到最后一章的内容<span id="more"></span></p><h1 id="MIT-18-06-Linear-Algebra"><a href="#MIT-18-06-Linear-Algebra" class="headerlink" title="MIT 18.06 Linear Algebra"></a>MIT 18.06 Linear Algebra</h1><p>不同于国内教材，这门课程</p><ul><li>基本完全依赖于向量以及向量空间</li><li>除了练习题之外，几乎没有严谨的定理和相关推论的推导</li><li>本书更加注重应用部分（介绍了马尔可夫矩阵，小波矩阵，傅里叶快速转化矩阵，复数矩阵和 matrix matriese（我不知道怎么翻译这个））</li><li>章节次序与以往的教材不同：<br>解线性方程 -&gt; 向量空间 -&gt; 正交性 -&gt; 行列式 -&gt; 特征值与特征向量 -&gt; 线性转换 -&gt; 应用</li></ul><p>笔记参照课程MIT 18.06记录，配套教材为《introduction to linear algebra》，国内由清华大学出版社出版影印版，目前无中文版。</p><div class="bvideo">    <a href="//www.bilibili.com/video/BV1ix411f7Yp" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/62f0e3f092f7b98b9968b237aec9bb706bb958d2.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">27:55:09</span>            </div>            <div class="bvideo-info">                <p class="title">【完整版-麻省理工-线性代数】全34讲+配套教材</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>153.2万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>2.2万</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">小风哥_ANGEL</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><p><img src="https://kawasaki12138.github.io/img/4.jpg" alt="avatar"></p><p><a href="https://kawasaki12138.github.io/pdf/LinearAlgebra-MEMEME.pdf">点击下载笔记</a></p><p><a href="https://kawasaki12138.github.io/pdf/Introduction_to_Linear_Algebra.pdf">点击下载配套教材</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> Linear algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIB:一杯苦酒</title>
      <link href="/2022/01/22/Yi/"/>
      <url>/2022/01/22/Yi/</url>
      
        <content type="html"><![CDATA[<p>雅科夫列夫曾任苏共中央宣传部长、政治局委员和总统顾问等重要职务，被认为是戈尔巴乔夫时期改革的倡导者，是苏联“公开化”运动的奠墓人。在本书中，作者从俄罗斯布尔什维主义的产生与发展讲起，剖析了布尔什维主义对苏联各个历史时期政治与社会生活的影响和作用。作者认为，在苏联经历了大清洗、第二次世界大战、冷战等各个历史时期之后，放弃人洞的革命理论，走改良这路，是惟一正确的发展道路。作者还认为，简单地导入不适合国情的西方民主制，给今天的俄罗斯带来了官僚主义盛行、国力不下降一系列恶果。 </p><p>作者表明，强大的俄罗斯不是靠军事实力获得的，它需要凭人民的美德和生活的质量来赢取。只有在法律至上并重视人的价值的条件下，俄罗斯才能走上正途。<span id="more"></span></p><h2 id="一怀苦酒——俄罗斯的布尔什维主义和改革运动"><a href="#一怀苦酒——俄罗斯的布尔什维主义和改革运动" class="headerlink" title="一怀苦酒——俄罗斯的布尔什维主义和改革运动"></a>一怀苦酒——俄罗斯的布尔什维主义和改革运动</h2><div class="row">    <embed src="https://kawasaki12138.github.io/pdf/Yi.pdf" width="100%" height="550" type="application/pdf"></div><p><a href="https://kawasaki12138.github.io/pdf/Yi.pdf">点击下载</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> CCCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analysis</title>
      <link href="/2021/07/16/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/"/>
      <url>/2021/07/16/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这是依照陶哲轩的《陶哲轩实分析》所记录的一份笔记。因为内容太多，现在先停更一段时间，有空再更。<span id="more"></span></p><h2 id="第二章-自然数-N"><a href="#第二章-自然数-N" class="headerlink" title="第二章   自然数 N"></a>第二章   自然数 N</h2><h3 id="2-1-皮亚诺定理"><a href="#2-1-皮亚诺定理" class="headerlink" title="2.1 皮亚诺定理"></a>2.1 皮亚诺定理</h3><h4 id="1-皮亚诺定理"><a href="#1-皮亚诺定理" class="headerlink" title="1. 皮亚诺定理"></a>1. 皮亚诺定理</h4><hr><p>​    <strong>自然数</strong>是集合</p><p>​                            N：={0，1，2，3…..}</p><p>​    的元素，其中，集合N是由0开始，无休止地往前进行计数所得到的所有元素构成的集合。我们称N为<strong>自然数集</strong></p><hr><p>​    虽然这个定理看起来显而易见，但是在这里我们并没有指明什么是计数，计数是否存在返回（即4=0）的现象，因此，我们对此定理进行规范化，并提出了五个公理，即</p><ul><li>0是一个自然数</li><li>如果n是自然数，那么n++也是一个自然数（在此基础上我们定义1：=0++）</li><li>0不是任何自然数的后继</li><li>若n！= m，则n++ != m++</li><li>令P(n)为自然数的某性质，若P(0)为真且P(n)为真时P(n++)为真，那么对于任一自然数n，P(n)一定为真。</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Planning in Summer Vacation</title>
      <link href="/2021/07/15/Planning-in-Summer-Vacation/"/>
      <url>/2021/07/15/Planning-in-Summer-Vacation/</url>
      
        <content type="html"><![CDATA[<p>​    这是2021年暑假的学习计划以及需要完成的目标，让我们看一下自己立下的FLAG能实现多少吧<span id="more"></span></p><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><ul><li>陶哲轩实分析     19章（已完成前4章）</li><li>数学建模             13章</li></ul><h2 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h2><ul><li>N5,N4单词        20单元</li><li>N3单词              20单元</li><li>N3语法              若干</li></ul><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><ul><li>learning from data         5章</li><li>javascript, html,  css       若干</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h3><ul><li>实分析完成至4.3</li><li>N5完成第3单元</li><li>DATA完成至1.3</li></ul><h3 id="8-04"><a href="#8-04" class="headerlink" title="8.04"></a>8.04</h3><ul><li>实分析 至第8章</li><li>N5完成</li><li>完成srdp框架制定</li><li>DATA完成至1.3</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/05/hello-world/"/>
      <url>/2021/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Amor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.<span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
