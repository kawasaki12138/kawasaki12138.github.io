<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>openwrt+docker+calibre:搭建家庭电子书库服务器</title>
      <link href="/2023/02/01/ebook-server/"/>
      <url>/2023/02/01/ebook-server/</url>
      
        <content type="html"><![CDATA[<p>前些天发现家里的软路由R2S里面openwrt系统里面预装了一个docker，于是突发奇想：能不能用R2S里面多余的存储空间搭建一个Calibre-web用来实现家庭内部的电子书数据库？说干就干，跟着网上的资料，经过两个小时的鏖战，最后我这个完全没接触过docker的纯菜鸟终于也完成这个应用的搭建。<span id="more"></span></p><p><strong>Calibre-web是什么：</strong></p><p>Calibre电子书管理解决方案，本地版使用了很多年，发现可以突破本地服务的局限，为自己的各种终端提供电子书服务。<br>Calibre-web就是calibre的web版，它提供了用户友好的对外网页展示的形式，可以在网上展示，管理，浏览自己的书籍，让书跟着自己走。</p><p>参考资料：</p><ul><li>[为openwrt里的docker扩容教程 - 腾讯云开发者社区-腾讯云 (tencent.com)](<a href="https://cloud.tencent.com/developer/article/1956624#:~:text=OpenWrt">https://cloud.tencent.com/developer/article/1956624#:~:text=OpenWrt</a> 扩容磁盘方案及实操 我们安装,OpenWrt 之后默认的存储空间都很小，如果你是通过下载其他大佬的固件，一般磁盘大小在编译固件的时候大小就固定死了，如果要跑 docker 的话会连)</li><li><a href="https://www.right.com.cn/forum/thread-4029912-1-1.html">小白试着用2个步骤在openwrt中docker部署”个人电子图书馆”-斐讯无线路由器以及其它斐迅网络设备-恩山无线论坛 (right.com.cn)</a></li><li><a href="https://www.bilibili.com/video/BV11G4y1t7sj/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=30c3a74835813dce01b41efe8f676cc7">【好玩儿的Docker项目】15分钟搭建一个在线电子书库/漫画/CG/画集库——Calibre-Web_哔哩哔哩_bilibili</a></li><li><a href="https://blog.laoda.de/archives/docker-compose-install-calibre-web">【好玩儿的Docker项目】15分钟搭建一个在线电子书库/漫画/CG/画集库——Calibre-Web (laoda.de)</a></li></ul><p><img src="https://kawasaki12138.github.io/img/ebook-server/01.png" alt="image-20230126191343910"></p><h2 id="第零步：docker的扩容"><a href="#第零步：docker的扩容" class="headerlink" title="第零步：docker的扩容"></a>第零步：docker的扩容</h2><h3 id="1-创建新分区"><a href="#1-创建新分区" class="headerlink" title="1. 创建新分区"></a>1. 创建新分区</h3><p>我当初购买的内置存储器是一块16GB的内存卡，对于只需要不到2GB的openwrt操作系统来说，实在有点大材小用了。因此当初我为内存卡分了一个12GB的空间用来作为网路共享存储器放着我珍贵的高清典藏无广告版《Yes，Prime minister》。随着三刷的结束，这12GB的空间终于被我释放用作docker的扩容。（当然如果使用外接设备比如说U盘也可以）</p><p>openwrt的默认docker容量只有不到一个1GB，这对于我们后续安装docker应用显然是不够的，因此第零步是对docker进行扩容。<strong>在这里我使用的远程登录软件是FinalShell。</strong><a href="http://www.hostbuf.com/downloads/finalshell_install.exe">windows版FinalShell下载</a>     <a href="http://www.hostbuf.com/downloads/finalshell_install.pkg">max版</a></p><p>话不多说，我们先用finalshell远程登录一下我们的openwrt检查我们的存储情况：</p><ul><li>点击左上角的图标按钮进入连接管理器 -&gt; 点击左上角的白色文件夹添加 -&gt; 选择SSH连接 -&gt; 输入账号密码，点击确认 -&gt; 进入远程页面</li></ul><p><img src="https://kawasaki12138.github.io/img/ebook-server/02.png" alt="新建连接"></p><p><img src="https://kawasaki12138.github.io/img/ebook-server/03.png" alt="连接成功"></p><p>输入查看当前磁盘分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p><img src="https://kawasaki12138.github.io/img/ebook-server/04.png"></p><p>linux系统没有windows里C盘D盘的概念，我们内存卡名称是mmcblk0，在这里我们内存卡下的第一个分区是mmcblk0p1，mmcblk0p2就是第二个分区，mmcblk0p3是我后期使用磁盘剩余空间建立的分区。</p><p>分区的规划我们同样可以在Openwrt系统内看到。点击“系统” –&gt;“磁盘管理”：</p><p><img src="https://kawasaki12138.github.io/img/ebook-server/05.png"></p><p>在这里我先将删掉mmcblk0p3，然后演示如何创建分区mmcblk0p3。</p><p>现在我们开始对内存卡进行分区，输入分区命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/mmcblk0</span><br></pre></td></tr></table></figure><ul><li>然后输入m可以查看有哪些操作：</li></ul><p><img src="https://kawasaki12138.github.io/img/ebook-server/06.png"></p><ul><li>输入n新建分区</li></ul><p><img src="https://kawasaki12138.github.io/img/ebook-server/07.png"></p><ul><li><p>输入p建立分区</p></li><li><p>partiton number: 输入defalt值就行，表示建立一个分区</p></li><li><p>First sector: 系统提示选择分区的起始扇区。</p><p>在这里使用内存作为分区的朋友要小心了，系统默认起始位置是第一块没有被挂载的分区，但是这块分区可能并不是我们希望的。就像我们之前检查的结果一样，分区1和分区2之间存在一块很小的空闲分区，如果我们此时选择敲回车默认，就会选中那块小分区，所以我们选择填入的数字应该比最后一块已经挂载的分区（mmcblk0p2）的end值要大，在这里我填的是2200000：</p><p><img src="https://kawasaki12138.github.io/img/ebook-server/08.png" alt="填入的数字应该比最后一块已经挂载的分区（mmcblk0p2）的end值要大"></p></li></ul><p><img src="https://kawasaki12138.github.io/img/ebook-server/09.png" alt="mmcblk0p1和mmcblk0p2之间存在16MB的小空闲分区"></p><ul><li><p>Last sector：敲回车默认就行，也可以选择分区大小，前提是大小要合适，否则报错</p></li><li><p>最后输入y确认分区参数，输入n是放弃</p></li><li><p>最后输入w写入分区表</p></li><li><p>输入fdisk -l查看新的磁盘信息</p><p><img src="https://kawasaki12138.github.io/img/ebook-server/04.png"></p></li><li><p>输入reboot重启系统同步磁盘信息</p></li><li><p>重启成功后输入，格式化mmcblk0p3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/mmcblk0p3</span><br></pre></td></tr></table></figure></li></ul><p>这样我们就拥有了一个分区。</p><blockquote><p>总结：<br>创建新分区 /dev/mmcblk0p3</p></blockquote><h3 id="2-将分区挂载在docker下"><a href="#2-将分区挂载在docker下" class="headerlink" title="2. 将分区挂载在docker下"></a>2. 将分区挂载在docker下</h3><p>打开openwrt，在“系统” - &gt; “挂载点” -&gt; 点击添加</p><p><img src="https://kawasaki12138.github.io/img/ebook-server/10.png" alt="挂载点目录下点击添加"></p><p><img src="https://ask.qcloudimg.com/http-save/9147629/3c7f0f6039f37d64142976752c511edd.png?imageView2/2/w/1620" alt="如果没有“作为docker数据分区使用”，就在自定义下填入“/opt”，点击保存并应用"></p><p>重启系统即可，此时我们docker有10.84GB可用</p><p><img src="https://kawasaki12138.github.io/img/ebook-server/11.png"></p><blockquote><p>总结：<br>新分区：/dev/mmcblk0p3<br>docker分区：/opt/docker/</p></blockquote><h2 id="第一步：安装calibre-web"><a href="#第一步：安装calibre-web" class="headerlink" title="第一步：安装calibre-web"></a>第一步：安装calibre-web</h2><ul><li><p>用SSH工具登陆openwrt，在外接硬盘上新建calibre文件夹，并在此文件夹内新建“config”、“books”两个文件夹。在这里我们的docker分区是/opt/docker/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/docker/calibre</span><br><span class="line">mkdir /opt/docker/calibre/config</span><br><span class="line">mkdir /opt/docker/calibre/books</span><br></pre></td></tr></table></figure></li><li><p><strong>安装linuxserver/calibre-web（电子图书馆）</strong></p><ul><li>在docker -&gt; 镜像 -&gt; 拉取镜像 中输入以下内容，点击拉取：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linuxserver/calibre-web</span><br></pre></td></tr></table></figure><p><img src="https://kawasaki12138.github.io/img/ebook-server/12.png" alt="拉取镜像"></p><ul><li><p>在docker -&gt; 容器 -&gt; 点击添加  -&gt;  选择命令行 -&gt; 输入如下内容，然后点击确定即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name calibre-web \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  -e PUID=1000 \</span><br><span class="line">  -e PGID=1000 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -v /opt/docker/calibre/config:/config \</span><br><span class="line">  -v /opt/docker/calibre/books:/books \</span><br><span class="line">  -p 8083:8083 \</span><br><span class="line">  -d linuxserver/calibre-web</span><br></pre></td></tr></table></figure><table><thead><tr><th><code>-p 8083</code></th><th>网页用户界面</th></tr></thead><tbody><tr><td><code>-e PUID=1000</code></td><td>对于用户 ID - 有关说明，请参阅下文</td></tr><tr><td><code>-e PGID=1000</code></td><td>对于组 ID - 有关说明，请参阅下文</td></tr><tr><td><code>-e TZ=Asia/Shanghai</code></td><td>指定使用 上海的时区。</td></tr><tr><td><code>-e DOCKER_MODS=linuxserver/mods:universal-calibre</code></td><td>仅#optional和<strong>x86-64</strong> 添加执行电子书转换的功能</td></tr><tr><td><code>-e OAUTHLIB_RELAX_TOKEN_SCOPE=1</code></td><td>（可选）设置此选项以允许 Google OAUTH 工作</td></tr><tr><td><code>-v /config</code></td><td>calibre-web 存储内部数据库和配置的位置。</td></tr><tr><td><code>-v /books</code></td><td>您先前存在的口径数据库所在的位置。</td></tr></tbody></table><p><em>*<em><strong>：</strong>PUID和PGID的内容，只需要cd /opt/docker/calibre，然后输入id即可查到</em>*</em>*</p></li><li><p>添加日志文件</p><p>将这个文件（<a href="https://www.right.com.cn/forum/forum.php?mod=attachment&aid=Mzg3NTI5fGI3NTdjYTQxfDE2NzUxNTI2ODl8MHw0MDI5OTEy">metadata.db</a>）复制到电子书存放路径下，对应我的路径就是“/opt/docker/calibre/books”，并且将其权限改为“读写”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /opt/docker/calibre/books/metadata.db</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>端口放行</strong></p><p>openwrt==》网络==》防火墙==》端口转发，在外部端口填入8083==》添加</p><p><img src="https://kawasaki12138.github.io/img/ebook-server/15.png"></p><p>这样我们就可以访问calibre-web了！</p></li></ul><blockquote><p>总结：</p><p>calibre-web地址：/opt/docker/calibre</p><p>calibre-web存储位置：/opt/docker/calibre/books</p><p>calibre-web日志位置：/opt/docker/calibre/config</p><p>端口：8083</p></blockquote><h2 id="第二步：配置calibre-web"><a href="#第二步：配置calibre-web" class="headerlink" title="第二步：配置calibre-web"></a>第二步：配置calibre-web</h2><ul><li><p><strong>配置数据库地址</strong></p><p>“数据库”的路径输入“/books”即可，然后点“登录”<img src="https://www.right.com.cn/forum/data/attachment/forum/202005/20/205451dzluoprzug8004qh.png"><strong>初次登录的用户名为：admin；密码为：admin123</strong></p></li><li><p><strong>更改语言</strong></p><p>登录后为英文，依次点选“admin”–”language”选择“中文”并保存即可</p></li><li><p><strong>后台启用上传</strong></p><p><img src="https://img.laoda.de/i/2022/11/11/p8ac67-2.webp"></p></li><li><p><strong>扩展程序配置（转换格式）</strong></p><p><img src="https://img.laoda.de/i/2022/11/11/p86rlk-2.webp"></p><p><img src="https://img.laoda.de/i/2022/11/11/p88jbb-2.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calibre 电子书转换器路径: /usr/bin/ebook-convert</span><br><span class="line">KEpubify 电子书转换器路径: /usr/bin/kepubify</span><br></pre></td></tr></table></figure></li><li><p><strong>启用用户阅读权限</strong></p><p><img src="https://img.laoda.de/i/2022/11/11/p8kqwo-2.webp"></p><p><img src="https://img.laoda.de/i/2022/11/11/p8m4h3-2.webp"></p></li></ul><p>各位自己慢慢摸索吧！</p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> openwrt </tag>
            
            <tag> docker </tag>
            
            <tag> calibre </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Game:NinNindays2攻略</title>
      <link href="/2022/08/05/ninnindays2/"/>
      <url>/2022/08/05/ninnindays2/</url>
      
        <content type="html"><![CDATA[<p>tmd，找了半天连游戏简介都找不到，中文互联网怎么变成这个样子！（五学震怒）<span id="more"></span></p><h2 id="NinNindays2简介-攻略-下载"><a href="#NinNindays2简介-攻略-下载" class="headerlink" title="NinNindays2简介/攻略/下载"></a>NinNindays2简介/攻略/下载</h2><p>游戏支持简体中文，以秋叶原为舞台，主角将与铃兰、桔梗两位美少女忍者一起展开同居生活，前作女主角堇也会登场。<br>《NinNinDays2》故事讲述的是在超市值夜班的主角，遇到来买肉包的少女和她的男友。两人非常亲热，让主角羡慕不已。随后又出现了两位忍者少女，他好心为女孩们买了便当。 但自从遇见这两位少女后，主角的生活就有了巨大转变。三个人竟然开始了吵闹幸福的同居生活， 一段忍术恋爱故事即将开始。</p><h3 id="1-单人结局"><a href="#1-单人结局" class="headerlink" title="1. 单人结局"></a>1. 单人结局</h3><ul><li><strong>铃兰结局：去女仆咖啡厅 -&gt; 穿巫女服 -&gt; 随便找个地方打发时间 -&gt; 让铃兰照顾 -&gt; 你们不会要去报仇吧？</strong></li><li><strong>桔梗结局：去中华料理店 -&gt; 穿魔法师服 -&gt; 前往碰面地点-&gt; 让桔梗照顾 -&gt; 你们不会要去报仇吧？</strong></li></ul><p><em><strong>：</strong>值得注意的是，前面四个选项中如果选错一个无伤大雅，不会引入</em>*BAD END<strong>，但是如果在最后一个选项中选择了 “你们要回去了吧？”，那么恭喜你喜提</strong>BAD END**。</p><h3 id="2-双人结局"><a href="#2-双人结局" class="headerlink" title="2. 双人结局"></a>2. 双人结局</h3><p><strong>注意：</strong>双人结局必须单独刷完两个单人结局之后才能进行，否则会进入<strong>BAD END</strong>（别问我怎么知道的）</p><ul><li><strong>双人结局：去中华料理店 -&gt; 穿巫女服 -&gt; 前往碰面地点-&gt; 让铃兰照顾 -&gt; 你们不会要去报仇吧？</strong></li></ul><p>打完之后，就会进入喜闻乐见的双人攻略情节了，最后祝各位身体健康！<a href="https://www.hacg.cat/wp/87957.html">点击下载游戏</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> galgames </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的leetcode</title>
      <link href="/2022/04/14/leetcode/"/>
      <url>/2022/04/14/leetcode/</url>
      
        <content type="html"><![CDATA[<p>郝斌老师：对于一个题目而言，有时候我们一写写上十几分钟一个小时就解来了；但是大多数时候，我们想了很久也没法解出问题，这个时候我们会备受打击。其实，写不出算法其实是正常的事情，包括那些大佬。学习算法，关键在于理解那些算法，学习算法的方法，应该先观察算法，算法流程 -&gt;每一部分功能 -&gt;自己试数，最后再尝试自己解决问题<span id="more"></span></p><h1 id="数组-amp-双指针"><a href="#数组-amp-双指针" class="headerlink" title="数组&amp;双指针"></a><strong>数组&amp;双指针</strong></h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：暴力破解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target,<span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> *temp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;numsSize;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] + nums[j] == target)&#123;</span><br><span class="line">                temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">                temp[<span class="number">0</span>]=i;</span><br><span class="line">                temp[<span class="number">1</span>]=j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参考答案：哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">hashtable</span>;</span><span class="comment">//这个貌似是必须先行定义，没法在函数中定义一个头</span></span><br><span class="line"><span class="comment">//这个指针对于uthash宏操作都需要是可见的，并且指针值会被修改，通常为全局变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hashTable* <span class="title">find</span><span class="params">(<span class="keyword">int</span> ikey)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> ikey, <span class="keyword">int</span> ival)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find(ikey);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;                                 <span class="comment">//若ikey没有，则插入</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct hashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                           <span class="comment">//若有则覆盖val的值</span></span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//流程如下：当输入num[0]=2时，先查找hash表中target-nums[0]=7的项目是否为空</span></span><br><span class="line"><span class="comment">//若为空，则插入项目key=2，val=0；</span></span><br><span class="line"><span class="comment">//若项目不为空，则输出找到的那个项目的val同时输出i即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    hashtable = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find(target - nums[i]);   <span class="comment">//每次查找key为target - nums[i]的项目是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;                                <span class="comment">//若it为空，则在key为nums[i]的地方插入value:i</span></span><br><span class="line">            <span class="keyword">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);          <span class="comment">//否则查询成功</span></span><br><span class="line">            ret[<span class="number">0</span>] = it-&gt;val, ret[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        insert(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的测试版本</span></span><br><span class="line"><span class="comment">//整了半天发现是要先行定义全局变量，否则没法用</span></span><br><span class="line"><span class="comment">//uthash具体使用方法：https://www.cnblogs.com/dongxb/p/14212531.html</span></span><br><span class="line"><span class="comment">//tmd，同一个测试样例，在leetcode上测试通过，但是提交的时候出错了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uthash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;hashtable,* hashlist;</span><br><span class="line"></span><br><span class="line">hashlist hashhead=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_users</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">hashlist <span class="title">find</span><span class="params">(<span class="keyword">int</span> iskey)</span></span>&#123;</span><br><span class="line">    hashlist s=<span class="literal">NULL</span>;</span><br><span class="line">    HASH_FIND_INT(hashhead,&amp;iskey,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;find\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> iskey,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    hashlist s=<span class="literal">NULL</span>;</span><br><span class="line">    s=find( iskey);</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        hashlist temp=(hashlist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hashtable));</span><br><span class="line">        temp-&gt;key=iskey;</span><br><span class="line">        temp-&gt;val=num;</span><br><span class="line">        HASH_ADD_INT( hashhead, key , temp );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;val=num;</span><br><span class="line">    &#125;</span><br><span class="line">    print_users();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;insert\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_users</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hashlist s;</span><br><span class="line">    <span class="keyword">for</span>(s=hashhead; s != <span class="literal">NULL</span>; s=(hashlist)(s-&gt;hh.next)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;user id %d: name %d\n&quot;</span>, s-&gt;key, s-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">2</span>]=&#123;<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> numsSize=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> returnSize;</span><br><span class="line">    <span class="keyword">int</span> *result=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in\n&quot;</span>);</span><br><span class="line">        hashlist temp=find(target-nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            result=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">            result[<span class="number">0</span>]=temp-&gt;val;</span><br><span class="line">            result[<span class="number">1</span>]=i;</span><br><span class="line">            returnSize=<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,result[<span class="number">0</span>],result[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            insert(nums[i],i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnSize=<span class="number">0</span>;</span><br><span class="line">    print_users();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的方法：归并排序，直接查找</span></span><br><span class="line"><span class="comment">//算法时间复杂度：o(m+n)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(nums1Size + nums2Size));</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums1Size&amp;&amp;k&lt;nums2Size)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[j]&lt;nums2[k])&#123;</span><br><span class="line">            temp[i]=nums1[j];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[i]=nums2[k];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums1Size)&#123;</span><br><span class="line">        temp[i]=nums1[j];</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;nums2Size)&#123;</span><br><span class="line">        temp[i]=nums2[k];</span><br><span class="line">         i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((nums1Size + nums2Size)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(temp[(nums1Size + nums2Size)/<span class="number">2</span>] + temp[(nums1Size + nums2Size)/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)temp[(nums1Size + nums2Size)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>]</span><br><span class="line">输出：[[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：三级循环 时间复杂度：o（n^3)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;);</span><br><span class="line">    numsSize=nums.length;</span><br><span class="line">    <span class="keyword">var</span> myArray=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">var</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;numsSize-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]===nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;numsSize-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=i+<span class="number">1</span> &amp;&amp; nums[j]===nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> k=j+<span class="number">1</span>;k&lt;numsSize;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k!=j+<span class="number">1</span> &amp;&amp; nums[k]===nums[k-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]==<span class="number">0</span>)&#123;</span><br><span class="line">                    myArray[length]=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">                    myArray[length][<span class="number">0</span>]=nums[i];</span><br><span class="line">                    myArray[length][<span class="number">1</span>]=nums[j];</span><br><span class="line">                    myArray[length][<span class="number">2</span>]=nums[k];</span><br><span class="line">                    length++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参考答案：双指针</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从小到大排序</span></span><br><span class="line">  <span class="keyword">const</span> arr = nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">  <span class="comment">// 最小值大于 0 或者 最大值小于 0，说明没有无效答案</span></span><br><span class="line">  <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; <span class="number">0</span> || arr[arr.length - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> n = arr.length;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前值大于 0，和右侧的值再怎么加也不会等于 0，所以直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前循环的值和上次循环的一样，就跳过，避免重复值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] === arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="comment">//一共有2个指针l,r分别指向i+1和n-1，当sum(arr[i]+arr[l]+arr[r])&lt;0时，l++</span></span><br><span class="line">    <span class="comment">//否则r--，直到二者相遇、遇到sum(arr[i]+arr[l]+arr[r])==0时，记录</span></span><br><span class="line">    <span class="comment">//重复跳过</span></span><br><span class="line">    <span class="keyword">let</span> l = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = arr[i] + arr[l] + arr[r];</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r --;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        l ++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp === <span class="number">0</span>) &#123;</span><br><span class="line">        res.push([nums[i], nums[l], nums[r]]);</span><br><span class="line">        <span class="comment">// 跳过重复值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">          l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">          r --;</span><br><span class="line">        &#125;</span><br><span class="line">        l ++;</span><br><span class="line">        r --;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：9596 ms, 在所有 JavaScript 提交中击败了4.99% 的用户</span><br><span class="line">内存消耗：48.8 MB, 在所有 JavaScript 提交中击败了90.26% 的用户</span><br></pre></td></tr></table></figure><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。必须在不使用库的sort函数的情况下解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br><span class="line"></span><br><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>你可以不使用代码库中的排序函数来解决这道题吗？</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：两次遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> numb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> numc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            numa++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">            numb++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">2</span>)&#123;</span><br><span class="line">            numc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(numa)&#123;</span><br><span class="line">        nums[i]=<span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        numa--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(numb)&#123;</span><br><span class="line">        nums[i]=<span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        numb--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(numc)&#123;</span><br><span class="line">        nums[i]=<span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">        numc--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//网友答案：一次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">sortColors</span>(<span class="params">int[] nums</span>)</span> &#123;</span><br><span class="line">        int num0 = <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;  <span class="comment">//遇到0时，所有排好序的数组推一格</span></span><br><span class="line">                nums[num2++] = <span class="number">2</span>;</span><br><span class="line">                nums[num1++] = <span class="number">1</span>;</span><br><span class="line">                nums[num0++] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>) &#123;<span class="comment">//遇到1时，1和2向前推一格</span></span><br><span class="line">                nums[num2++] = <span class="number">2</span>;</span><br><span class="line">                nums[num1++] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;                 <span class="comment">//遇到2时，2向前推一格</span></span><br><span class="line">                nums[num2++] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：64 ms, 在所有 JavaScript 提交中击败了54.46%的用户</span><br><span class="line">内存消耗：41.1 MB, 在所有 JavaScript 提交中击败了59.27%的用户</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 </p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>解法：最小覆盖串</p><p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: t 中两个字符 <span class="string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">100000</span>, maxStartIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> needWhich = &#123;&#125;; <span class="comment">// 这里存 t 子串中各字符的数量，即需要满足的个数</span></span><br><span class="line">    <span class="keyword">let</span> windowAll = &#123;&#125;; <span class="comment">// 这里存滑动窗口遍历过程中，处于滑动窗口内部的 t 中的字符</span></span><br><span class="line">    <span class="comment">// 初始化 needWhich，总共需要哪些字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> t) &#123;</span><br><span class="line">        needWhich[val] = (needWhich[val] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> len = s.length, nowSatisfy = <span class="number">0</span>; <span class="comment">// 要多少个键值对满足 needWhich 中的才算覆盖</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; len) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = s[right]; <span class="comment">// 右指针当前遍历到的字符</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是 t 字符串中字符</span></span><br><span class="line">        <span class="keyword">if</span>(needWhich[key]) &#123;</span><br><span class="line">            windowAll[key] = (windowAll[key] || <span class="number">0</span>) + <span class="number">1</span>; <span class="comment">// 当前滑动窗口的该键，值 + 1</span></span><br><span class="line">            <span class="comment">// 如果读取到这个字符后，该字符总数 === 覆盖的子串中的该字符总数了，那就总数 + 1</span></span><br><span class="line">            <span class="keyword">if</span>(windowAll[key] === needWhich[key]) &#123;</span><br><span class="line">                nowSatisfy++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当验证数量与需要的字符个数一致时，说明是覆盖子串了，接下来要找最小的也就是应该收缩窗口了</span></span><br><span class="line">        <span class="keyword">while</span>(nowSatisfy === <span class="built_in">Object</span>.keys(needWhich).length) &#123;</span><br><span class="line">            <span class="comment">// 更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; maxLength) &#123;</span><br><span class="line">                maxStartIndex = left;</span><br><span class="line">                maxLength = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//即将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">const</span> outKey = s[left];</span><br><span class="line">            <span class="comment">// 窗口左边界右移</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 如果是 t 字符串中字符</span></span><br><span class="line">            <span class="keyword">if</span>(needWhich[outKey]) &#123;</span><br><span class="line">                <span class="comment">// 对于要移出窗口的这个字符的个数，如果 窗口内部 和 t 中的相同，即没有多余，那么 nowSatisfy--，开始找下一滑动窗口了，否则还得继续移除该字符</span></span><br><span class="line">                <span class="keyword">if</span> (windowAll[outKey] === needWhich[outKey]) &#123;</span><br><span class="line">                    nowSatisfy--;</span><br><span class="line">                &#125;</span><br><span class="line">                windowAll[outKey]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxStartIndex === -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.slice(maxStartIndex, maxStartIndex + maxLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II "></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II </a></h2><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>example1:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>example2:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解答：暴力破解，每次查找数组中是否存在此地址，不存在则在数组中存入此地址</span></span><br><span class="line"><span class="comment">//直到链表指针域为NULL或出现在数组中</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> **<span class="title">temp</span>=</span>(struct ListNode **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode *)*<span class="number">10001</span>);</span><br><span class="line">    temp[<span class="number">0</span>]=head;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i]==p-&gt;next)</span><br><span class="line">                <span class="keyword">return</span> temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp[length++]=p-&gt;next;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">124</span> ms, 在所有 C 提交中击败了<span class="number">5.49</span>%的用户</span><br><span class="line">内存消耗：<span class="number">7.5</span> MB, 在所有 C 提交中击败了<span class="number">5.95</span>%的用户</span><br></pre></td></tr></table></figure><p><strong>参考答案：快慢指针</strong></p><p>思路与算法</p><p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为<br>$$<br>a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc<br>$$<br>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 22 倍。因此，我们有<br>$$<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br>$$<br>有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">detectCycle</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">ptr</span> =</span> head;</span><br><span class="line">            <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的新解</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span>=</span>head;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || slow-&gt;next==<span class="literal">NULL</span> ||fast-&gt;next-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">NULL</span> &amp;&amp; slow!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;next == <span class="literal">NULL</span>) &#123;  <span class="comment">//小心！如果不写这个if语句可能导致</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;           <span class="comment">//fast=fast-&gt;next-&gt;next报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow==fast &amp;&amp; slow!=<span class="literal">NULL</span> &amp;&amp; fast!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>=</span>head;</span><br><span class="line">            <span class="keyword">while</span>(p!=slow)&#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                slow=slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点数目在范围[1, 105] 内</li><li>0 &lt;= Node.val &lt;= 9</li></ul><p>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//我的解法：头尾指针</span></span><br><span class="line"><span class="comment">//我的其他想法：栈，空间复杂度减半，但是要多遍历一回，数量级不变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100001</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">rear</span>=</span>head;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(rear!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp[len++]=rear-&gt;val;</span><br><span class="line">        rear=rear-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;len/<span class="number">2</span>;i++,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[i]!=temp[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：快慢指针，快指针走完的时候慢指针刚好跑一半，然后将后半/前半反转</span></span><br><span class="line"><span class="comment">//最后判断是否相等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;  <span class="comment">//背下来算了。。。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextTemp</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">endOfFirstHalf</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">firstHalfEnd</span> =</span> endOfFirstHalf(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">secondHalfStart</span> =</span> reverseList(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否回文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p2</span> =</span> secondHalfStart;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">    firstHalfEnd-&gt;next = reverseList(secondHalfStart);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">0</span>]</span><br><span class="line">输出: [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：同颜色分类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num0=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            temp=nums[i];</span><br><span class="line">            nums[num0++]=<span class="number">0</span>;</span><br><span class="line">            nums[num1++]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nums[num0++]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">76</span> ms, 在所有 C 提交中击败了<span class="number">77.79</span>%的用户</span><br><span class="line">内存消耗：<span class="number">14.8</span> MB, 在所有 C 提交中击败了<span class="number">41.01</span>%的用户</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h1><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的题解：快慢表（伪）</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">rear</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">point</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span>=</span>head;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(count!=n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        rear=rear-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(rear-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre=point;</span><br><span class="line">        rear=rear-&gt;next;</span><br><span class="line">        point=point-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(point==head)&#123;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pre-&gt;next=point-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">4</span> ms, 在所有 C 提交中击败了<span class="number">52.54</span>%的用户</span><br><span class="line">内存消耗：<span class="number">5.6</span> MB, 在所有 C 提交中击败了<span class="number">76.74</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓展：栈</span></span><br><span class="line"><span class="comment">//我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 </span></span><br><span class="line"><span class="comment">//nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删</span></span><br><span class="line"><span class="comment">//除操作就变得十分方便了。</span></span><br><span class="line"><span class="comment">//亲测没我的快 :)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">val</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>, dummy-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">stk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Stack));</span><br><span class="line">        tmp-&gt;val = cur, tmp-&gt;next = stk;</span><br><span class="line">        stk = tmp;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>* <span class="title">tmp</span> =</span> stk-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(stk);</span><br><span class="line">        stk = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> stk-&gt;val;</span><br><span class="line">    prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">ans</span> =</span> dummy-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//他奶奶的，用链表的冒泡排序虽然可以让时间复杂度降为常数，但是会直接超时</span></span><br><span class="line"><span class="comment">//只能直接借助系统的sort（）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        ListNode* rear=head;</span><br><span class="line">        <span class="keyword">while</span>(rear!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            result.push_back(rear-&gt;val);</span><br><span class="line">            rear=rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        rear=head;</span><br><span class="line">        sort(result.begin(),result.end());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rear!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            rear-&gt;val=result[i++];</span><br><span class="line">            rear=rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></p><p><strong>题目数据</strong> 保证 整个链式结构中不存在环。</p><p><strong>注意，函数返回结果后，链表必须 保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li><li>listA - 第一个链表</li><li>listB - 第二个链表</li><li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li><li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p> <strong>exp1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Intersected at <span class="string">&#x27;8&#x27;</span></span><br><span class="line">解释：相交节点的值为 <span class="number">8</span> （注意，如果两个链表相交则不能为 <span class="number">0</span>）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。</span><br><span class="line">在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure><p><strong>exp2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//我的解法：暴力法，直接将所有地址存下来，然后倒序查找（其实可以直接用哈希查找会快一点）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode *&gt; tempa;</span><br><span class="line">        vector&lt;ListNode *&gt; tempb;</span><br><span class="line">        ListNode* a=headA;</span><br><span class="line">        ListNode* b=headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tempa.<span class="built_in">push_back</span>(a);</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tempb.<span class="built_in">push_back</span>(b);</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num_a=tempa.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num_b=tempb.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num_a&gt;=<span class="number">0</span>&amp;&amp;num_b&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempa[num_a]==tempb[num_b])&#123;</span><br><span class="line">                num_a--;</span><br><span class="line">                num_b--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num_a==tempa.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tempa[num_a+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">44</span> ms, 在所有 C++ 提交中击败了<span class="number">41.48</span>%的用户</span><br><span class="line">内存消耗：<span class="number">16.4</span> MB, 在所有 C++ 提交中击败了<span class="number">20.78</span>%的用户</span><br></pre></td></tr></table></figure><p><strong>参考答案：</strong></p><p><img src="https://pic.leetcode-cn.com/1615224578-lFxRVR-Picture2.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-atzfoi-Picture3.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-QvNyxe-Picture4.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-zPMkyB-Picture5.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-MRfzKN-Picture6.png"><img src="https://pic.leetcode-cn.com/1615224578-UIHyvx-Picture7.png"><img src="https://pic.leetcode-cn.com/1615224578-fyOdzW-Picture8.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-LcVJxI-Picture9.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：快慢表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *a=headA;</span><br><span class="line">        ListNode *b=headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            a=a==<span class="literal">nullptr</span>?headB:a-&gt;next;</span><br><span class="line">            b=b==<span class="literal">nullptr</span>?headA:b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>exp:</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：暴力堆栈（伪）</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            temp.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;val=temp[i--];</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的解法二：反转指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ptr=head;</span><br><span class="line">        ListNode* p=head-&gt;next;</span><br><span class="line">        ptr-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* rear=p-&gt;next;</span><br><span class="line">            p-&gt;next=ptr;</span><br><span class="line">            ptr=p;</span><br><span class="line">            p=rear;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=ptr;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">4</span> ms, 在所有 C++ 提交中击败了<span class="number">96.18</span>%的用户</span><br><span class="line">内存消耗：<span class="number">8.2</span> MB, 在所有 C++ 提交中击败了<span class="number">24.63</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">8</span> ms, 在所有 C++ 提交中击败了<span class="number">49.54</span>%的用户</span><br><span class="line">内存消耗：<span class="number">8.1</span> MB, 在所有 C++ 提交中击败了<span class="number">45.94</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//答案方法：优化版解法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列&amp;栈"></a><strong>队列&amp;栈</strong></h1><h2 id="20-有效的括号（栈-字符串的处理）"><a href="#20-有效的括号（栈-字符串的处理）" class="headerlink" title="20. 有效的括号（栈/字符串的处理）"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a>（栈/字符串的处理）</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：栈（其实也想不到其他的解法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;&#123;&#x27;</span>||s[i]==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                temp.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!temp.<span class="built_in">empty</span>()&amp;&amp;temp.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    temp.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!temp.<span class="built_in">empty</span>()&amp;&amp;temp.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    temp.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!temp.<span class="built_in">empty</span>()&amp;&amp;temp.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    temp.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!temp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.empty();         <span class="comment">//如果栈为空则返回true, 否则返回false;</span></span><br><span class="line">s.size();          <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">s.top();           <span class="comment">//返回栈顶元素, 但不删除该元素</span></span><br><span class="line">s.pop();           <span class="comment">//弹出栈顶元素, 但不返回其值</span></span><br><span class="line">s.push();          <span class="comment">//将元素压入栈顶</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;      <span class="comment">//声明一个栈</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">&quot;helloWorld&quot;</span>;        <span class="comment">//逐个读取字符串字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">0</span> ms, 在所有 C++ 提交中击败了<span class="number">100.00</span>%的用户</span><br><span class="line">内存消耗：<span class="number">6.1</span> MB, 在所有 C++ 提交中击败了<span class="number">73.63</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大佬的解法：利用ascii码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push_back</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.<span class="built_in">empty</span>() == <span class="literal">true</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] - stack.<span class="built_in">back</span>() == <span class="number">1</span> || s[i] - stack.<span class="built_in">back</span>() == <span class="number">2</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里用的就是正常的归并，就不再赘述了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* head=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* curr=head;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">nullptr</span>&amp;&amp;list2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123;</span><br><span class="line">                curr-&gt;next=list1;</span><br><span class="line">                list1=list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next=list2;</span><br><span class="line">                list2=list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;next=list1==<span class="literal">nullptr</span>?list2:list1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">4</span> ms, 在所有 C++ 提交中击败了<span class="number">92.47</span>%的用户</span><br><span class="line">内存消耗：<span class="number">14.4</span> MB, 在所有 C++ 提交中击败了<span class="number">43.43</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> <strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：单调栈</span></span><br><span class="line"><span class="comment">//详见https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> size = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;                                                    <span class="comment">//从左向右遍历</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; heights[stk.<span class="built_in">top</span>()] &gt; heights[i]) &#123;                       <span class="comment">//当出现一个严格小于栈内的height时</span></span><br><span class="line">                <span class="keyword">int</span> length = heights[stk.<span class="built_in">top</span>()];                                            <span class="comment">//退栈，同时计算矩形宽度</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> weight = i;</span><br><span class="line">                <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    weight = i - stk.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, length * weight);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);                                                                      <span class="comment">//压栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = heights[stk.<span class="built_in">top</span>()];</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> weight = size;</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                weight = size - stk.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, length * weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a></h2><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>exp:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p>参考答案：（单调栈）</p><p><img src="https://pic.leetcode-cn.com/aabb1b287134cf950aa80526806ef4025e3920d57d237c0369ed34fae83e2690-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class="line">        <span class="comment">//遍历每一列，更新高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; matrix[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                heights[col] += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heights[col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用上一题的解法，更新函数</span></span><br><span class="line">        maxArea = Math.<span class="built_in">max</span>(maxArea, <span class="built_in">largestRectangleArea</span>(heights));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; heights.length) &#123;</span><br><span class="line">        <span class="comment">//栈空入栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(p);</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> top = stack.<span class="built_in">peek</span>();</span><br><span class="line">            <span class="comment">//当前高度大于栈顶，入栈</span></span><br><span class="line">            <span class="keyword">if</span> (heights[p] &gt;= heights[top]) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(p);</span><br><span class="line">                p++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//保存栈顶高度</span></span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.<span class="built_in">pop</span>()];</span><br><span class="line">                <span class="comment">//左边第一个小于当前柱子的下标</span></span><br><span class="line">                <span class="keyword">int</span> leftLessMin = stack.<span class="built_in">isEmpty</span>() ? <span class="number">-1</span> : stack.<span class="built_in">peek</span>();</span><br><span class="line">                <span class="comment">//右边第一个小于当前柱子的下标</span></span><br><span class="line">                <span class="keyword">int</span> RightLessMin = p;</span><br><span class="line">                <span class="comment">//计算面积</span></span><br><span class="line">                <span class="keyword">int</span> area = (RightLessMin - leftLessMin - <span class="number">1</span>) * height;</span><br><span class="line">                maxArea = Math.<span class="built_in">max</span>(area, maxArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">//保存栈顶高度</span></span><br><span class="line">        <span class="keyword">int</span> height = heights[stack.<span class="built_in">pop</span>()];</span><br><span class="line">        <span class="comment">//左边第一个小于当前柱子的下标</span></span><br><span class="line">        <span class="keyword">int</span> leftLessMin = stack.<span class="built_in">isEmpty</span>() ? <span class="number">-1</span> : stack.<span class="built_in">peek</span>();</span><br><span class="line">        <span class="comment">//右边没有小于当前高度的柱子，所以赋值为数组的长度便于计算</span></span><br><span class="line">        <span class="keyword">int</span> RightLessMin = heights.length;</span><br><span class="line">        <span class="keyword">int</span> area = (RightLessMin - leftLessMin - <span class="number">1</span>) * height;</span><br><span class="line">        maxArea = Math.<span class="built_in">max</span>(area, maxArea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li>MinStack() 初始化堆栈对象。</li><li>void push(int val) 将元素val推入堆栈。</li><li>void pop() 删除堆栈顶部的元素。</li><li>int top() 获取堆栈顶部的元素。</li><li>int getMin() 获取堆栈中的最小元素。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MinStack&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;getMin&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;top&quot;</span>,<span class="string">&quot;getMin&quot;</span>]</span><br><span class="line">[[],[<span class="number">-2</span>],[<span class="number">0</span>],[<span class="number">-3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,<span class="number">-3</span>,null,<span class="number">0</span>,<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(<span class="number">-3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 <span class="number">-3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; 返回 <span class="number">-2.</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：哨兵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MinStack</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; MinStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">MinStack* <span class="title">minStackCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MinStack* head=(MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    head-&gt;val=<span class="number">12138</span>;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPush</span><span class="params">(MinStack* obj, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    MinStack* q=obj;</span><br><span class="line">    MinStack* p=(MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    p-&gt;val=val;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next=p;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;val==<span class="number">12138</span>)&#123;</span><br><span class="line">        obj-&gt;val=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(obj-&gt;val&gt;val)&#123;</span><br><span class="line">        obj-&gt;val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPop</span><span class="params">(MinStack* obj)</span> </span>&#123;</span><br><span class="line">    MinStack* p=obj;</span><br><span class="line">    MinStack* before;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        before=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=p-&gt;val;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    before-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==obj-&gt;val)&#123;</span><br><span class="line">        MinStack* q=obj-&gt;next;</span><br><span class="line">        obj-&gt;val=<span class="number">12138</span>;</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            obj-&gt;val=q-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val&lt;obj-&gt;val)&#123;</span><br><span class="line">                obj-&gt;val=q-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackTop</span><span class="params">(MinStack* obj)</span> </span>&#123;</span><br><span class="line">    MinStack* q=obj-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackGetMin</span><span class="params">(MinStack* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackFree</span><span class="params">(MinStack* obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = minStackCreate();</span></span><br><span class="line"><span class="comment"> * minStackPush(obj, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = minStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_4 = minStackGetMin(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">136</span> ms, 在所有 C 提交中击败了<span class="number">33.06</span>%的用户</span><br><span class="line">内存消耗：<span class="number">12.8</span> MB, 在所有 C 提交中击败了<span class="number">67.69</span>%的用户</span><br></pre></td></tr></table></figure><p><strong>参考答案：</strong></p><p>可以用一个栈，这个栈同时保存的是每个数字 x 进栈的时候的值 与 插入该值后的栈内最小值。即每次新元素 x 入栈的时候保存一个元组：（当前值 x，栈内最小值）。</p><p>这个元组是一个整体，同时进栈和出栈。即栈顶同时有值和栈内最小值，top()函数是获取栈顶的当前值，即栈顶元组的第一个值； getMin() 函数是获取栈内最小值，即栈顶元组的第二个值；pop() 函数时删除栈顶的元组。</p><p>每次新元素入栈时，要求新的栈内最小值：比较当前新插入元素 x 和 当前栈内最小值（即栈顶元组的第二个值）的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(&#123;x, x&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(&#123;x, <span class="built_in">min</span>(x, st.<span class="built_in">top</span>().second)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解答：首次遍历最大值，之后若最大值退出窗口，则重新遍历求最值，</span></span><br><span class="line"><span class="comment">//否则已知最大值和推入窗口的值比较</span></span><br><span class="line"><span class="comment">//结果：超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> num=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> maxPosition = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        temp.<span class="built_in">push_back</span>(*maxPosition);</span><br><span class="line">        <span class="keyword">int</span> curr=*maxPosition;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr==temp[i-k])&#123;</span><br><span class="line">                maxPosition = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>()+i-k+<span class="number">1</span>, nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(*maxPosition);</span><br><span class="line">                curr=*maxPosition;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp[i]&gt;curr)&#123;</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(temp[i]);</span><br><span class="line">                    curr=temp[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(curr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/">参考答案</a>：</p><p>遍历数组，将 数 存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用双向队列。</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">//窗口尾部超过了k，则将最左边的元素移除</span></span><br><span class="line">            <span class="comment">//依据性质，窗口下标一定是按照时间顺序向前的</span></span><br><span class="line">            <span class="keyword">if</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() == i - k) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="comment">//从后往前移除所有队列中小于当前元素的元素</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[dq.<span class="built_in">back</span>()])&#123;</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在队列中添加当前元素</span></span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">//窗口第一次到达k，则在结果中插入最大值(deque最前面的元素)</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k<span class="number">-1</span>) res.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">208</span> ms, 在所有 C++ 提交中击败了<span class="number">84.11</span>%的用户</span><br><span class="line">内存消耗：<span class="number">131.5</span> MB, 在所有 C++ 提交中击败了<span class="number">31.15</span>%的用户</span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;3[a]2[bc]&quot;</span></span><br><span class="line">输出：<span class="string">&quot;aaabcbc&quot;</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;3[a2[c]]&quot;</span></span><br><span class="line">输出：<span class="string">&quot;accaccacc&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：栈（毫无疑问）</span></span><br><span class="line"><span class="comment">//为啥字符串就那么难弄呢？:(</span></span><br><span class="line"><span class="comment">//思路大概都能想得到，但是到实操一大堆问题</span></span><br><span class="line"><span class="comment">//思路：1.可以直接用&lt;string&gt;不用&lt;char&gt;那种垃圾</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        stack &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        stack &lt;string&gt; strs;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) ||(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                res = res + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>) <span class="comment">//将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                strs.<span class="built_in">push</span>(res); </span><br><span class="line">                res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> times = nums.<span class="built_in">top</span>();</span><br><span class="line">                nums.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; times; ++ j)</span><br><span class="line">                    strs.<span class="built_in">top</span>() += res;</span><br><span class="line">                res = strs.<span class="built_in">top</span>(); <span class="comment">//之后若还是字母，就会直接加到res之后，因为它们是同一级的运算</span></span><br><span class="line">                                  <span class="comment">//若是左括号，res会被压入strs栈，作为上一层的运算</span></span><br><span class="line">                strs.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//我的重写：报错（这道题是真的难解）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; times;</span><br><span class="line">        stack&lt;string&gt; st;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>||s[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                temp+=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                st.<span class="built_in">push</span>(temp);</span><br><span class="line">                temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> int1=<span class="built_in">stoi</span>(&amp;s[i-j]);</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                times.<span class="built_in">push</span>(int1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> t=times.<span class="built_in">top</span>();</span><br><span class="line">                string q=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;t;k++)&#123;</span><br><span class="line">                    st.<span class="built_in">top</span>()+=temp;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                times.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [<span class="number">73</span>,<span class="number">74</span>,<span class="number">75</span>,<span class="number">71</span>,<span class="number">69</span>,<span class="number">72</span>,<span class="number">76</span>,<span class="number">73</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">输入: temperatures = [<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">输入: temperatures = [<span class="number">30</span>,<span class="number">60</span>,<span class="number">90</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的方法：队列</span></span><br><span class="line"><span class="comment">//先将所有元素的result置零</span></span><br><span class="line"><span class="comment">//创建一个队列，每次取一个tempture跟队头比较，若队头元素小于tempture则退队</span></span><br><span class="line"><span class="comment">//同时记录时间差值录入result</span></span><br><span class="line"><span class="comment">//依次进行，直到找到比它大的元素，将tempture加入队头</span></span><br><span class="line"><span class="comment">//参考答案和我的解法差不多，在此就不多做展示了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        result.<span class="built_in">resize</span>(temperatures.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">fill</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        deque&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; temp;</span><br><span class="line">        temp.<span class="built_in">push_front</span>(&#123;<span class="number">0</span>,temperatures[<span class="number">0</span>]&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;temperatures.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!temp.<span class="built_in">empty</span>() &amp;&amp; temperatures[i]&gt;temp.<span class="built_in">front</span>().second)&#123;</span><br><span class="line">                result[temp.<span class="built_in">front</span>().first]=i-temp.<span class="built_in">front</span>().first;</span><br><span class="line">                temp.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp.<span class="built_in">push_front</span>(&#123;i,temperatures[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">128</span> ms, 在所有 C++ 提交中击败了<span class="number">84.33</span>%的用户</span><br><span class="line">内存消耗：<span class="number">90.9</span> MB, 在所有 C++ 提交中击败了<span class="number">5.04</span>%的用户</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的方法：deququ滑动窗口+哈希查询</span></span><br><span class="line"><span class="comment">//注：如果不用pair而是直接记录最后用size（）记录大小也可以，但是时间会下降</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; signal;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        signal.<span class="built_in">resize</span>(<span class="number">300</span>);</span><br><span class="line">        <span class="built_in">fill</span>(signal.<span class="built_in">begin</span>(),signal.<span class="built_in">end</span>(),<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ss=(<span class="keyword">int</span>)s[i];</span><br><span class="line">            <span class="keyword">if</span>(signal[ss]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> k=temp.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span>(k&gt;max)&#123;</span><br><span class="line">                    max=k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(!temp.<span class="built_in">empty</span>() &amp;&amp; temp.<span class="built_in">front</span>()!=ss)&#123;</span><br><span class="line">                    signal[temp.<span class="built_in">front</span>()]=<span class="number">-1</span>;</span><br><span class="line">                    temp.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                temp.<span class="built_in">pop_front</span>();</span><br><span class="line">                temp.<span class="built_in">push_back</span>(ss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                signal[ss]=<span class="number">1</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(ss);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=temp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;max)&#123;</span><br><span class="line">            max=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：滑动窗口（比我的简单）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">4</span> ms, 在所有 C++ 提交中击败了<span class="number">97.40</span>%的用户</span><br><span class="line">内存消耗：<span class="number">9.3</span> MB, 在所有 C++ 提交中击败了<span class="number">49.54</span>%的用户</span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><strong>哈希表</strong></h1><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h2><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;bat&quot;</span>],[<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],[<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>]]</span><br><span class="line"></span><br><span class="line">输入: strs = [<span class="string">&quot;&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;&quot;</span>]]</span><br><span class="line"></span><br><span class="line">输入: strs = [<span class="string">&quot;a&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;a&quot;</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网友解法：用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。其余步骤就是用map存储，和别人的一致了。</span></span><br><span class="line"><span class="comment">//我没复现出来，新方法太多了:(</span></span><br><span class="line"><span class="comment">//auto：</span></span><br><span class="line"><span class="comment">//map:</span></span><br><span class="line"><span class="comment">//str:strs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        map&lt;<span class="keyword">double</span>,vector&lt;string&gt;&gt; cmap;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">double</span> code[<span class="number">26</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:strs)&#123;</span><br><span class="line">            <span class="keyword">double</span> sum=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch:str) &#123;</span><br><span class="line">                sum*=code[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cmap[sum].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> vs:cmap)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vs.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>exp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长数字连续序列是 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。它的长度为 <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+<span class="number">1</span>==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;max)&#123;</span><br><span class="line">                    max=temp;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;max)&#123;</span><br><span class="line">            max=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">56</span> ms, 在所有 C++ 提交中击败了<span class="number">81.50</span>%的用户</span><br><span class="line">内存消耗：<span class="number">33</span> MB, 在所有 C++ 提交中击败了<span class="number">22.82</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：哈希表</span></span><br><span class="line"><span class="comment">//先把所有的数值扔进哈希表中</span></span><br><span class="line"><span class="comment">//然后开始遍历哈希表</span></span><br><span class="line"><span class="comment">//对于哈希表中任意一个数值i，如果i-1不存在（不存在相邻并且比它小的数字），则进行下一步</span></span><br><span class="line"><span class="comment">//统计每一个相邻并且比它大的数字，更新数值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (num_set.<span class="built_in">count</span>(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longestStreak = <span class="built_in">max</span>(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//我的复现：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num:num_set)&#123;   <span class="comment">//为什么要用const int&amp; ?</span></span><br><span class="line">            <span class="keyword">if</span>(num_set.<span class="built_in">count</span>(num<span class="number">-1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr=num;</span><br><span class="line">                <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(num_set.<span class="built_in">count</span>(curr+<span class="number">1</span>))&#123;</span><br><span class="line">                    curr++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                result=result&lt;count?count:result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//for(const int&amp; num:num_set)&#123;&#125;</span></span><br><span class="line"><span class="comment">//for (auto iter = uset.begin(); iter != uset.end(); ++iter) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *iter &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>exp:</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：哈希表（用快慢表也可以）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">count</span>(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(head);</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：16 ms, 在所有 C++ 提交中击败了23.55%的用户</span><br><span class="line">内存消耗：10.2 MB, 在所有 C++ 提交中击败了21.41%的用户</span><br></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表，结果错误</span></span><br><span class="line"><span class="comment">//草，今天才知道unordered_set的insert根本没法计数，何必去设计count函数误导人</span></span><br><span class="line"><span class="comment">//count函数直接设计成isEmpty不就行了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        set.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">count</span>(sum-k)!=<span class="number">0</span>)&#123;</span><br><span class="line">                result+=set.<span class="built_in">count</span>(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            set.<span class="built_in">insert</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：递归</span></span><br><span class="line"><span class="comment">//为什么使用vector&lt;int&gt;&amp; temp（引用类型）？详见下面</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temp,TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">trans</span>(temp,root-&gt;left);</span><br><span class="line">            temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">trans</span>(temp,root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">trans</span>(temp,root);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="引用与指针-主要是引用"><a href="#引用与指针-主要是引用" class="headerlink" title="引用与指针(主要是引用)"></a>引用与指针(主要是引用)</h3><blockquote><ul><li><p>指针：是一个变量，存储的是一个地址，指向内存的一个存储单元；</p></li><li><p>引用：是原变量的一个别名，跟原来的变量实质上是同一个东西.</p></li></ul><p>以下示例程序中，k 被初始化为i的引用。语句 k = j 并不能将 k 修改成为j的引用，只是把k的值改变成为 6。由于 k 是 i 的引用，所以i的值也变成了 6。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">int</span> &amp;k = i; </span><br><span class="line">k = j; <span class="comment">// k 和 i 的值都变成了 6;</span></span><br></pre></td></tr></table></figure><p>引用的规则：</p><ul><li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li><li>不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。</li><li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li></ul><p>C++ 语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x = x + <span class="number">10</span>; </span><br><span class="line">&#125; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line">Func1(n); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// n = 0 </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于 Func2 函数体内的 x 是指向外部变量 n 的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> *x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    (* x) = (* x) + <span class="number">10</span>; </span><br><span class="line">&#125; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line">Func2(&amp;n); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// n = 10 </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    x = x + <span class="number">10</span>; </span><br><span class="line">&#125; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line">Func3(n); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// n = 10</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：递归</span></span><br><span class="line"><span class="comment">//自己实在记不得怎么弄了。。。参考了答案自己重写了一个</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(TreeNode* p,TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;!q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p||!q)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val==q-&gt;val &amp;&amp; <span class="built_in">cmp</span>(p-&gt;left,q-&gt;right) &amp;&amp; <span class="built_in">cmp</span>(p-&gt;right,q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p> <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">3</span>],[<span class="number">9</span>,<span class="number">20</span>],[<span class="number">15</span>,<span class="number">7</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：层序遍历+头尾指针</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        deque&lt;TreeNode*&gt; p;</span><br><span class="line">        p.<span class="built_in">push_back</span>(root);</span><br><span class="line">        TreeNode* top=root;</span><br><span class="line">        TreeNode* rear=root;</span><br><span class="line">        <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* q=p.<span class="built_in">front</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(q-&gt;val);</span><br><span class="line">            p.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;left)&#123;</span><br><span class="line">                p.<span class="built_in">push_back</span>(q-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;right)&#123;</span><br><span class="line">                p.<span class="built_in">push_back</span>(q-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q==rear)&#123;</span><br><span class="line">                rear=p.<span class="built_in">back</span>();</span><br><span class="line">                top=p.<span class="built_in">front</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                temp.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">8</span> ms, 在所有 C++ 提交中击败了<span class="number">23.02</span>%的用户</span><br><span class="line">内存消耗：<span class="number">12.1</span> MB, 在所有 C++ 提交中击败了<span class="number">76.63</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网友解法：先序遍历（递归），每次直接push</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">pre</span>(root, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode *root, <span class="keyword">int</span> depth, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= ans.<span class="built_in">size</span>())</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt; &#123;&#125;);<span class="comment">//说明这一层还没来过，这是第一次来，所以得扩容</span></span><br><span class="line">        ans[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;left, depth + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;right, depth + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：递归</span></span><br><span class="line"><span class="comment">//好吧，我也不知道有啥可解的，课本上的原题</span></span><br><span class="line"><span class="comment">//不知道为啥，我把return部分改为三元表达式会超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">4</span> ms, 在所有 C++ 提交中击败了<span class="number">90.39</span>%的用户</span><br><span class="line">内存消耗：<span class="number">18.2</span> MB, 在所有 C++ 提交中击败了<span class="number">97.63</span>%的用户</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：递归</span></span><br><span class="line"><span class="comment">//结合中序遍历和先序遍历的特点</span></span><br><span class="line"><span class="comment">//先序：[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</span></span><br><span class="line"><span class="comment">//中序：[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildNode</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x1&gt;y1||x2&gt;y2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[x1]);</span><br><span class="line">        <span class="keyword">int</span> i=x2;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=y2;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[x1]==inorder[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> LL=i-x2;</span><br><span class="line">        node-&gt;left=<span class="built_in">buildNode</span>(preorder,inorder,x1+<span class="number">1</span>,x1+LL,x2,i<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right=<span class="built_in">buildNode</span>(preorder,inorder,x1+LL+<span class="number">1</span>,y1,i+<span class="number">1</span>,y2);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode* tree=<span class="built_in">buildNode</span>(preorder,inorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">44</span> ms, 在所有 C++ 提交中击败了<span class="number">13.02</span>%的用户</span><br><span class="line">内存消耗：<span class="number">25.3</span> MB, 在所有 C++ 提交中击败了<span class="number">70.43</span>%的用户</span><br></pre></td></tr></table></figure><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li><li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li></ul><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的解法：栈（非递归先序遍历）</span></span><br><span class="line"><span class="comment">//将结果存入vector中，最后再链接</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; temp1;</span><br><span class="line">        stack&lt;TreeNode*&gt; temp2;</span><br><span class="line">        TreeNode* p=root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span> != p)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">NULL</span>!=p)&#123;</span><br><span class="line">                temp1.<span class="built_in">push_back</span>(p);</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span>!=p-&gt;right)&#123;</span><br><span class="line">                    temp2.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!temp2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                p=temp2.<span class="built_in">top</span>();</span><br><span class="line">                temp2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp1.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            temp1[i]-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            temp1[i]-&gt;right=temp1[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        temp1[temp1.<span class="built_in">size</span>()<span class="number">-1</span>]-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        temp1[temp1.<span class="built_in">size</span>()<span class="number">-1</span>]-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不需要vector的版本，用一个pre指针即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; temp2;</span><br><span class="line">        TreeNode* p=root;</span><br><span class="line">        TreeNode* q=root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span> != p)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">NULL</span>!=p)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p!=q)&#123;</span><br><span class="line">                    q-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">                    q-&gt;right=p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">NULL</span>!=p-&gt;right)&#123;</span><br><span class="line">                    temp2.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                q=p;</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!temp2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                p=temp2.<span class="built_in">top</span>();</span><br><span class="line">                temp2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：<span class="number">0</span> ms, 在所有 C++ 提交中击败了<span class="number">100.00</span>%的用户</span><br><span class="line">内存消耗：<span class="number">12.5</span> MB, 在所有 C++ 提交中击败了<span class="number">36.80</span>%的用户</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：递归</span></span><br><span class="line">TreeNode* last = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">flatten(root-&gt;right);</span><br><span class="line">flatten(root-&gt;left);</span><br><span class="line">root-&gt;right = last;</span><br><span class="line">root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span></span><br><span class="line">         / \</span><br><span class="line">        <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">       / \     </span><br><span class="line">      <span class="number">4</span>   <span class="number">5</span>    </span><br><span class="line"><span class="comment">//返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考答案：递归</span></span><br><span class="line"><span class="comment">//感觉递归就是玄学，想得到的时候就很快，想不到就白搭</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="built_in">depth</span>(rt-&gt;left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="built_in">depth</span>(rt-&gt;right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOTE:MIT 18.06 Linear Algebra</title>
      <link href="/2022/03/07/linear-algebra/"/>
      <url>/2022/03/07/linear-algebra/</url>
      
        <content type="html"><![CDATA[<p>这是一份关于MIT 18.06的线性代数笔记，同时包含配套英文教材《introduction to linear algebra》，这份笔记记载了从第三章到最后一章的内容<span id="more"></span></p><p>不同于国内教材，这门课程</p><ul><li>基本完全依赖于向量以及向量空间</li><li>除了练习题之外，几乎没有严谨的定理和相关推论的推导</li><li>本书更加注重应用部分（介绍了马尔可夫矩阵，小波矩阵，傅里叶快速转化矩阵，复数矩阵和 matrix matriese（我不知道怎么翻译这个））</li><li>章节次序与以往的教材不同：<br>解线性方程 -&gt; 向量空间 -&gt; 正交性 -&gt; 行列式 -&gt; 特征值与特征向量 -&gt; 线性转换 -&gt; 应用</li></ul><p>笔记参照课程MIT 18.06记录，配套教材为《introduction to linear algebra》，国内由清华大学出版社出版影印版，目前无中文版。</p><div class="bvideo">    <a href="//www.bilibili.com/video/BV1ix411f7Yp" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/62f0e3f092f7b98b9968b237aec9bb706bb958d2.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">27:55:09</span>            </div>            <div class="bvideo-info">                <p class="title">【完整版-麻省理工-线性代数】全34讲+配套教材</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>184.2万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>2.6万</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">小风哥_ANGEL</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><p><img src="https://kawasaki12138.github.io/img/4.jpg" alt="avatar"></p><p><a href="https://kawasaki12138.github.io/pdf/linear-MEMEME.pdf">点击下载笔记</a></p><p><a href="https://kawasaki12138.github.io/pdf/Introduction_to_Linear_Algebra.pdf">点击下载配套教材</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> Linear algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIB:一怀苦酒——俄罗斯的布尔什维主义和改革运动</title>
      <link href="/2022/01/22/Yi/"/>
      <url>/2022/01/22/Yi/</url>
      
        <content type="html"><![CDATA[<p>雅科夫列夫曾任苏共中央宣传部长、政治局委员和总统顾问等重要职务，被认为是戈尔巴乔夫时期改革的倡导者，是苏联“公开化”运动的奠墓人。在本书中，作者从俄罗斯布尔什维主义的产生与发展讲起，剖析了布尔什维主义对苏联各个历史时期政治与社会生活的影响和作用。作者认为，在苏联经历了大清洗、第二次世界大战、冷战等各个历史时期之后，放弃人洞的革命理论，走改良这路，是惟一正确的发展道路。作者还认为，简单地导入不适合国情的西方民主制，给今天的俄罗斯带来了官僚主义盛行、国力不下降一系列恶果。 </p><p>作者表明，强大的俄罗斯不是靠军事实力获得的，它需要凭人民的美德和生活的质量来赢取。只有在法律至上并重视人的价值的条件下，俄罗斯才能走上正途。<span id="more"></span></p><div class="row">    <embed src="https://kawasaki12138.github.io/pdf/Yi.pdf" width="100%" height="550" type="application/pdf"></div><p><a href="https://kawasaki12138.github.io/pdf/Yi.pdf">点击下载</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> CCCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOTE:陶哲轩实分析</title>
      <link href="/2021/07/16/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/"/>
      <url>/2021/07/16/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这是依照陶哲轩的《陶哲轩实分析》所记录的一份笔记。因为内容太多，现在先停更一段时间，有空再更。<span id="more"></span></p><h2 id="第二章-自然数-N"><a href="#第二章-自然数-N" class="headerlink" title="第二章   自然数 N"></a>第二章   自然数 N</h2><h3 id="2-1-皮亚诺定理"><a href="#2-1-皮亚诺定理" class="headerlink" title="2.1 皮亚诺定理"></a>2.1 皮亚诺定理</h3><h4 id="1-皮亚诺定理"><a href="#1-皮亚诺定理" class="headerlink" title="1. 皮亚诺定理"></a>1. 皮亚诺定理</h4><hr><p>​    <strong>自然数</strong>是集合</p><p>​                            N：={0，1，2，3…..}</p><p>​    的元素，其中，集合N是由0开始，无休止地往前进行计数所得到的所有元素构成的集合。我们称N为<strong>自然数集</strong></p><hr><p>​    虽然这个定理看起来显而易见，但是在这里我们并没有指明什么是计数，计数是否存在返回（即4=0）的现象，因此，我们对此定理进行规范化，并提出了五个公理，即</p><ul><li>0是一个自然数</li><li>如果n是自然数，那么n++也是一个自然数（在此基础上我们定义1：=0++）</li><li>0不是任何自然数的后继</li><li>若n！= m，则n++ != m++</li><li>令P(n)为自然数的某性质，若P(0)为真且P(n)为真时P(n++)为真，那么对于任一自然数n，P(n)一定为真。</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Planning in Summer Vacation</title>
      <link href="/2021/07/15/Planning-in-Summer-Vacation/"/>
      <url>/2021/07/15/Planning-in-Summer-Vacation/</url>
      
        <content type="html"><![CDATA[<p>​    这是2021年暑假的学习计划以及需要完成的目标，让我们看一下自己立下的FLAG能实现多少吧<span id="more"></span></p><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><ul><li>陶哲轩实分析     19章（已完成前4章）</li><li>数学建模             13章</li></ul><h2 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h2><ul><li>N5,N4单词        20单元</li><li>N3单词              20单元</li><li>N3语法              若干</li></ul><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><ul><li>learning from data         5章</li><li>javascript, html,  css       若干</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h3><ul><li>实分析完成至4.3</li><li>N5完成第3单元</li><li>DATA完成至1.3</li></ul><h3 id="8-04"><a href="#8-04" class="headerlink" title="8.04"></a>8.04</h3><ul><li>实分析 至第8章</li><li>N5完成</li><li>完成srdp框架制定</li><li>DATA完成至1.3</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/05/hello-world/"/>
      <url>/2021/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Amor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.<span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
