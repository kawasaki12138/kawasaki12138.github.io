<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的leetcode</title>
      <link href="/2022/04/14/leetcode/"/>
      <url>/2022/04/14/leetcode/</url>
      
        <content type="html"><![CDATA[<p>郝斌老师：对于一个题目而言，有时候我们一写写上十几分钟一个小时就解来了；但是大多数时候，我们想了很久也没法解出问题，这个时候我们会备受打击。其实，写不出算法其实是正常的事情，包括那些大佬。学习算法，关键在于理解那些算法，学习算法的方法，应该先观察算法，算法流程 -&gt;每一部分功能 -&gt;自己试数，最后再尝试自己解决问题<span id="more"></span></p><h1 id="数组-amp-双指针"><a href="#数组-amp-双指针" class="headerlink" title="数组&amp;双指针"></a><strong>数组&amp;双指针</strong></h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解法：暴力破解</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span>* returnSize)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j;<br>    <span class="hljs-keyword">int</span> *temp=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++)&#123;<br>            <span class="hljs-keyword">if</span>( nums[i] + nums[j] == target)&#123;<br>                temp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">2</span>);<br>                temp[<span class="hljs-number">0</span>]=i;<br>                temp[<span class="hljs-number">1</span>]=j;<br>                *returnSize = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">//参考答案：哈希表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span> &#123;</span><br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> val;<br>    UT_hash_handle hh;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">hashtable</span>;</span><span class="hljs-comment">//这个貌似是必须先行定义，没法在函数中定义一个头</span><br><span class="hljs-comment">//这个指针对于uthash宏操作都需要是可见的，并且指针值会被修改，通常为全局变量。</span><br><br><span class="hljs-function">struct hashTable* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ikey)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span>;</span><br>    HASH_FIND_INT(hashtable, &amp;ikey, tmp);<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ikey, <span class="hljs-keyword">int</span> ival)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(ikey);<br>    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">NULL</span>) &#123;                                 <span class="hljs-comment">//若ikey没有，则插入</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct hashTable));<br>        tmp-&gt;key = ikey, tmp-&gt;val = ival;<br>        HASH_ADD_INT(hashtable, key, tmp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;                                           <span class="hljs-comment">//若有则覆盖val的值</span><br>        it-&gt;val = ival;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//流程如下：当输入num[0]=2时，先查找hash表中target-nums[0]=7的项目是否为空</span><br><span class="hljs-comment">//若为空，则插入项目key=2，val=0；</span><br><span class="hljs-comment">//若项目不为空，则输出找到的那个项目的val同时输出i即可</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>* returnSize)</span> </span>&#123;<br>    hashtable = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(target - nums[i]);   <span class="hljs-comment">//每次查找key为target - nums[i]的项目是否为空</span><br>        <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">NULL</span>) &#123;                                <span class="hljs-comment">//若it为空，则在key为nums[i]的地方插入value:i</span><br>            <span class="hljs-keyword">int</span>* ret = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">2</span>);          <span class="hljs-comment">//否则查询成功</span><br>            ret[<span class="hljs-number">0</span>] = it-&gt;val, ret[<span class="hljs-number">1</span>] = i;<br>            *returnSize = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        insert(nums[i], i);<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的测试版本</span><br><span class="hljs-comment">//整了半天发现是要先行定义全局变量，否则没法用</span><br><span class="hljs-comment">//uthash具体使用方法：https://www.cnblogs.com/dongxb/p/14212531.html</span><br><span class="hljs-comment">//tmd，同一个测试样例，在leetcode上测试通过，但是提交的时候出错了</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;uthash.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span> &#123;</span><br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> val;<br>    UT_hash_handle hh;<br>&#125;hashtable,* hashlist;<br><br>hashlist hashhead=<span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_users</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">hashlist <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iskey)</span></span>&#123;<br>    hashlist s=<span class="hljs-literal">NULL</span>;<br>    HASH_FIND_INT(hashhead,&amp;iskey,s);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iskey,<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    hashlist s=<span class="hljs-literal">NULL</span>;<br>    s=find( iskey);<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>)&#123;<br>        hashlist temp=(hashlist)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashtable));<br>        temp-&gt;key=iskey;<br>        temp-&gt;val=num;<br>        HASH_ADD_INT( hashhead, key , temp );<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        s-&gt;val=num;<br>    &#125;<br>    print_users();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;insert\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_users</span><span class="hljs-params">()</span> </span>&#123;<br>    hashlist s;<br>    <span class="hljs-keyword">for</span>(s=hashhead; s != <span class="hljs-literal">NULL</span>; s=(hashlist)(s-&gt;hh.next)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;user id %d: name %d\n&quot;</span>, s-&gt;key, s-&gt;val);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> nums[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-keyword">int</span> numsSize=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> target=<span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">int</span> returnSize;<br>    <span class="hljs-keyword">int</span> *result=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in\n&quot;</span>);<br>        hashlist temp=find(target-nums[i]);<br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>            result=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">2</span>);<br>            result[<span class="hljs-number">0</span>]=temp-&gt;val;<br>            result[<span class="hljs-number">1</span>]=i;<br>            returnSize=<span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            insert(nums[i],i);<br><br>        &#125;<br>    &#125;<br>    returnSize=<span class="hljs-number">0</span>;<br>    print_users();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], nums2 = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 (<span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的方法：归并排序，直接查找</span><br><span class="hljs-comment">//算法时间复杂度：o(m+n)</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums1, <span class="hljs-keyword">int</span> nums1Size, <span class="hljs-keyword">int</span>* nums2, <span class="hljs-keyword">int</span> nums2Size)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> *temp=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*(nums1Size + nums2Size));<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(j&lt;nums1Size&amp;&amp;k&lt;nums2Size)&#123;<br>        <span class="hljs-keyword">if</span>(nums1[j]&lt;nums2[k])&#123;<br>            temp[i]=nums1[j];<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp[i]=nums2[k];<br>            i++;<br>            k++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;nums1Size)&#123;<br>        temp[i]=nums1[j];<br>        i++;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(k&lt;nums2Size)&#123;<br>        temp[i]=nums2[k];<br>         i++;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((nums1Size + nums2Size)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(temp[(nums1Size + nums2Size)/<span class="hljs-number">2</span>] + temp[(nums1Size + nums2Size)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>])/<span class="hljs-number">2.0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)temp[(nums1Size + nums2Size)/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>]<br>输出：[[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br><br>输入：nums = []<br>输出：[]<br><br>输入：nums = [<span class="hljs-number">0</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//我的解法：三级循环 时间复杂度：o（n^3)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    nums.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<span class="hljs-keyword">return</span> a-b&#125;);<br>    numsSize=nums.length;<br>    <span class="hljs-keyword">var</span> myArray=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>    <span class="hljs-keyword">var</span> length=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;numsSize-<span class="hljs-number">2</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span> &amp;&amp; nums[i]===nums[i-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize-<span class="hljs-number">1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j!=i+<span class="hljs-number">1</span> &amp;&amp; nums[j]===nums[j-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k=j+<span class="hljs-number">1</span>;k&lt;numsSize;k++)&#123;<br>                <span class="hljs-keyword">if</span>(k!=j+<span class="hljs-number">1</span> &amp;&amp; nums[k]===nums[k-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[j]+nums[k]==<span class="hljs-number">0</span>)&#123;<br>                    myArray[length]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);<br>                    myArray[length][<span class="hljs-number">0</span>]=nums[i];<br>                    myArray[length][<span class="hljs-number">1</span>]=nums[j];<br>                    myArray[length][<span class="hljs-number">2</span>]=nums[k];<br>                    length++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> myArray;<br>&#125;;<br><br><span class="hljs-comment">//参考答案：双指针</span><br><span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br>  <span class="hljs-comment">// 从小到大排序</span><br>  <span class="hljs-keyword">const</span> arr = nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a-b);<br>  <span class="hljs-comment">// 最小值大于 0 或者 最大值小于 0，说明没有无效答案</span><br>  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> || arr[arr.length - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br>  <span class="hljs-keyword">const</span> n = arr.length;<br>  <span class="hljs-keyword">const</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-comment">// 如果当前值大于 0，和右侧的值再怎么加也不会等于 0，所以直接退出</span><br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 当前循环的值和上次循环的一样，就跳过，避免重复值</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; arr[i] === arr[i - <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 双指针</span><br>    <span class="hljs-comment">//一共有2个指针l,r分别指向i+1和n-1，当sum(arr[i]+arr[l]+arr[r])&lt;0时，l++</span><br>    <span class="hljs-comment">//否则r--，直到二者相遇、遇到sum(arr[i]+arr[l]+arr[r])==0时，记录</span><br>    <span class="hljs-comment">//重复跳过</span><br>    <span class="hljs-keyword">let</span> l = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>      <span class="hljs-keyword">const</span> temp = arr[i] + arr[l] + arr[r];<br>      <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<br>        r --;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span>) &#123;<br>        l ++;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (temp === <span class="hljs-number">0</span>) &#123;<br>        res.push([nums[i], nums[l], nums[r]]);<br>        <span class="hljs-comment">// 跳过重复值</span><br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[l + <span class="hljs-number">1</span>]) &#123;<br>          l ++;<br>        &#125;<br>        <span class="hljs-comment">// 同上</span><br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[r - <span class="hljs-number">1</span>]) &#123;<br>          r --;<br>        &#125;<br>        l ++;<br>        r --;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">执行用时：<span class="hljs-number">9596</span> ms, 在所有 JavaScript 提交中击败了<span class="hljs-number">4.99</span><span class="hljs-comment">% 的用户</span><br>内存消耗：<span class="hljs-number">48.8</span> MB, 在所有 JavaScript 提交中击败了<span class="hljs-number">90.26</span><span class="hljs-comment">% 的用户</span><br></code></pre></td></tr></table></figure><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。必须在不使用库的sort函数的情况下解决这个问题。</p><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-comment">[0,0,1,1,2,2]</span><br><br>输入：nums = <span class="hljs-comment">[2,0,1]</span><br>输出：<span class="hljs-comment">[0,1,2]</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>你可以不使用代码库中的排序函数来解决这道题吗？</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//我的解法：两次遍历</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortColors = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> numa=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> numb=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> numc=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)&#123;<br>            numa++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">1</span>)&#123;<br>            numb++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">2</span>)&#123;<br>            numc++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(numa)&#123;<br>        nums[i]=<span class="hljs-number">0</span>;<br>        i++;<br>        numa--;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(numb)&#123;<br>        nums[i]=<span class="hljs-number">1</span>;<br>        i++;<br>        numb--;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(numc)&#123;<br>        nums[i]=<span class="hljs-number">2</span>;<br>        i++;<br>        numc--;<br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-comment">//网友答案：一次遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">sortColors</span>(<span class="hljs-params">int[] nums</span>)</span> &#123;<br>        int num0 = <span class="hljs-number">0</span>, num1 = <span class="hljs-number">0</span>, num2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//遇到0时，所有排好序的数组推一格</span><br>                nums[num2++] = <span class="hljs-number">2</span>;<br>                nums[num1++] = <span class="hljs-number">1</span>;<br>                nums[num0++] = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//遇到1时，1和2向前推一格</span><br>                nums[num2++] = <span class="hljs-number">2</span>;<br>                nums[num1++] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">//遇到2时，2向前推一格</span><br>                nums[num2++] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">执行用时：<span class="hljs-number">64</span> ms, 在所有 JavaScript 提交中击败了<span class="hljs-number">54.46</span><span class="hljs-comment">%的用户</span><br>内存消耗：<span class="hljs-number">41.1</span> MB, 在所有 JavaScript 提交中击败了<span class="hljs-number">59.27</span><span class="hljs-comment">%的用户</span><br></code></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 </p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>解法：最小覆盖串</p><p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br><br>输入：s = <span class="hljs-string">&quot;a&quot;</span>, t = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br><br>输入: s = <span class="hljs-string">&quot;a&quot;</span>, t = <span class="hljs-string">&quot;aa&quot;</span><br>输出: <span class="hljs-string">&quot;&quot;</span><br>解释: t 中两个字符 <span class="hljs-string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//参考答案</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">100000</span>, maxStartIndex = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> needWhich = &#123;&#125;; <span class="hljs-comment">// 这里存 t 子串中各字符的数量，即需要满足的个数</span><br>    <span class="hljs-keyword">let</span> windowAll = &#123;&#125;; <span class="hljs-comment">// 这里存滑动窗口遍历过程中，处于滑动窗口内部的 t 中的字符</span><br>    <span class="hljs-comment">// 初始化 needWhich，总共需要哪些字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> t) &#123;<br>        needWhich[val] = (needWhich[val] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = s.length, nowSatisfy = <span class="hljs-number">0</span>; <span class="hljs-comment">// 要多少个键值对满足 needWhich 中的才算覆盖</span><br>    <span class="hljs-keyword">while</span>(right &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> key = s[right]; <span class="hljs-comment">// 右指针当前遍历到的字符</span><br>        right++;<br><br>        <span class="hljs-comment">// 如果是 t 字符串中字符</span><br>        <span class="hljs-keyword">if</span>(needWhich[key]) &#123;<br>            windowAll[key] = (windowAll[key] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前滑动窗口的该键，值 + 1</span><br>            <span class="hljs-comment">// 如果读取到这个字符后，该字符总数 === 覆盖的子串中的该字符总数了，那就总数 + 1</span><br>            <span class="hljs-keyword">if</span>(windowAll[key] === needWhich[key]) &#123;<br>                nowSatisfy++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 当验证数量与需要的字符个数一致时，说明是覆盖子串了，接下来要找最小的也就是应该收缩窗口了</span><br>        <span class="hljs-keyword">while</span>(nowSatisfy === <span class="hljs-built_in">Object</span>.keys(needWhich).length) &#123;<br>            <span class="hljs-comment">// 更新最小覆盖子串</span><br>            <span class="hljs-keyword">if</span> (right - left &lt; maxLength) &#123;<br>                maxStartIndex = left;<br>                maxLength = right - left;<br>            &#125;<br>            <span class="hljs-comment">//即将移出窗口的字符</span><br>            <span class="hljs-keyword">const</span> outKey = s[left];<br>            <span class="hljs-comment">// 窗口左边界右移</span><br>            left++;<br>            <span class="hljs-comment">// 如果是 t 字符串中字符</span><br>            <span class="hljs-keyword">if</span>(needWhich[outKey]) &#123;<br>                <span class="hljs-comment">// 对于要移出窗口的这个字符的个数，如果 窗口内部 和 t 中的相同，即没有多余，那么 nowSatisfy--，开始找下一滑动窗口了，否则还得继续移除该字符</span><br>                <span class="hljs-keyword">if</span> (windowAll[outKey] === needWhich[outKey]) &#123;<br>                    nowSatisfy--;<br>                &#125;<br>                windowAll[outKey]--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxStartIndex === -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.slice(maxStartIndex, maxStartIndex + maxLength);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II "></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II </a></h2><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>example1:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], pos = <span class="hljs-number">1</span><br>输出：返回索引为 <span class="hljs-number">1</span> 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p>example2:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>], pos = <span class="hljs-number">-1</span><br>输出：返回 null<br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解答：暴力破解，每次查找数组中是否存在此地址，不存在则在数组中存入此地址</span><br><span class="hljs-comment">//直到链表指针域为NULL或出现在数组中</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">struct ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(struct ListNode *head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> **<span class="hljs-title">temp</span>=</span>(struct ListNode **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode *)*<span class="hljs-number">10001</span>);<br>    temp[<span class="hljs-number">0</span>]=head;<br>    <span class="hljs-keyword">int</span> length=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(temp[i]==p-&gt;next)<br>                <span class="hljs-keyword">return</span> temp[i];<br>        &#125;<br>        temp[length++]=p-&gt;next;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">124</span> ms, 在所有 C 提交中击败了<span class="hljs-number">5.49</span>%的用户<br>内存消耗：<span class="hljs-number">7.5</span> MB, 在所有 C 提交中击败了<span class="hljs-number">5.95</span>%的用户<br></code></pre></td></tr></table></figure><p><strong>参考答案：快慢指针</strong></p><p>思路与算法</p><p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为<br>$$<br>a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc<br>$$<br>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 22 倍。因此，我们有<br>$$<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br>$$<br>有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参考答案</span><br><span class="hljs-function">struct ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span> =</span> head, *fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) &#123;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">ptr</span> =</span> head;<br>            <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                ptr = ptr-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//我的新解</span><br><span class="hljs-function">struct ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(struct ListNode *head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">fast</span>=</span>head;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span> || slow-&gt;next==<span class="hljs-literal">NULL</span> ||fast-&gt;next-&gt;next==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span> &amp;&amp; slow!=<span class="hljs-literal">NULL</span>)&#123;<br>        slow=slow-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//小心！如果不写这个if语句可能导致</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;           <span class="hljs-comment">//fast=fast-&gt;next-&gt;next报错</span><br>        &#125;<br>        fast=fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span>(slow==fast &amp;&amp; slow!=<span class="hljs-literal">NULL</span> &amp;&amp; fast!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p</span>=</span>head;<br>            <span class="hljs-keyword">while</span>(p!=slow)&#123;<br>                p=p-&gt;next;<br>                slow=slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点数目在范围[1, 105] 内</li><li>0 &lt;= Node.val &lt;= 9</li></ul><p>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//我的解法：头尾指针</span><br><span class="hljs-comment">//我的其他想法：栈，空间复杂度减半，但是要多遍历一回，数量级不变</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(struct ListNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> *temp=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">100001</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rear</span>=</span>head;<br>    <span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(rear!=<span class="hljs-literal">NULL</span>)&#123;<br>        temp[len++]=rear-&gt;val;<br>        rear=rear-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j=len<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(;i&lt;len/<span class="hljs-number">2</span>;i++,j--)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i]!=temp[j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参考答案：快慢指针，快指针走完的时候慢指针刚好跑一半，然后将后半/前半反转</span><br><span class="hljs-comment">//最后判断是否相等</span><br><br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;  <span class="hljs-comment">//背下来算了。。。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">prev</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">curr</span> =</span> head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">nextTemp</span> =</span> curr-&gt;next;<br>        curr-&gt;next = prev;<br>        prev = curr;<br>        curr = nextTemp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(struct ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到前半部分链表的尾节点并反转后半部分链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">firstHalfEnd</span> =</span> endOfFirstHalf(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">secondHalfStart</span> =</span> reverseList(firstHalfEnd-&gt;next);<br><br>    <span class="hljs-comment">// 判断是否回文</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p1</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p2</span> =</span> secondHalfStart;<br>    <span class="hljs-keyword">bool</span> result = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (result &amp;&amp; p2 != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;<br>            result = <span class="hljs-literal">false</span>;<br>        &#125;<br>        p1 = p1-&gt;next;<br>        p2 = p2-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 还原链表并返回结果</span><br>    firstHalfEnd-&gt;next = reverseList(secondHalfStart);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入: nums = [<span class="hljs-number">0</span>]<br>输出: [<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解法：同颜色分类</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num1=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num0=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">if</span>(numsSize==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)&#123;<br>            temp=nums[i];<br>            nums[num0++]=<span class="hljs-number">0</span>;<br>            nums[num1++]=temp;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            nums[num0++]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">76</span> ms, 在所有 C 提交中击败了<span class="hljs-number">77.79</span>%的用户<br>内存消耗：<span class="hljs-number">14.8</span> MB, 在所有 C 提交中击败了<span class="hljs-number">41.01</span>%的用户<br></code></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h1><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>], n = <span class="hljs-number">1</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], n = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的题解：快慢表（伪）</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(struct ListNode* head, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rear</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">point</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span>head;<br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(count!=n)&#123;<br>        count++;<br>        rear=rear-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(rear-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        pre=point;<br>        rear=rear-&gt;next;<br>        point=point-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(point==head)&#123;<br>        head=head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        pre-&gt;next=point-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">4</span> ms, 在所有 C 提交中击败了<span class="hljs-number">52.54</span>%的用户<br>内存消耗：<span class="hljs-number">5.6</span> MB, 在所有 C 提交中击败了<span class="hljs-number">76.74</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//拓展：栈</span><br><span class="hljs-comment">//我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 </span><br><span class="hljs-comment">//nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删</span><br><span class="hljs-comment">//除操作就变得十分方便了。</span><br><span class="hljs-comment">//亲测没我的快 :)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">val</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-function">struct ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(struct ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">dummy</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct ListNode));<br>    dummy-&gt;val = <span class="hljs-number">0</span>, dummy-&gt;next = head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">stk</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span> =</span> dummy;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">tmp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Stack));<br>        tmp-&gt;val = cur, tmp-&gt;next = stk;<br>        stk = tmp;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>* <span class="hljs-title">tmp</span> =</span> stk-&gt;next;<br>        <span class="hljs-built_in">free</span>(stk);<br>        stk = tmp;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">prev</span> =</span> stk-&gt;val;<br>    prev-&gt;next = prev-&gt;next-&gt;next;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">ans</span> =</span> dummy-&gt;next;<br>    <span class="hljs-built_in">free</span>(dummy);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//他奶奶的，用链表的冒泡排序虽然可以让时间复杂度降为常数，但是会直接超时</span><br><span class="hljs-comment">//只能直接借助系统的sort（）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>||head-&gt;next==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        ListNode* rear=head;<br>        <span class="hljs-keyword">while</span>(rear!=<span class="hljs-literal">NULL</span>)&#123;<br>            result.push_back(rear-&gt;val);<br>            rear=rear-&gt;next;<br>        &#125;<br>        rear=head;<br>        sort(result.begin(),result.end());<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(rear!=<span class="hljs-literal">NULL</span>)&#123;<br>            rear-&gt;val=result[i++];<br>            rear=rear-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></p><p><strong>题目数据</strong> 保证 整个链式结构中不存在环。</p><p><strong>注意，函数返回结果后，链表必须 保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li><li>listA - 第一个链表</li><li>listB - 第二个链表</li><li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li><li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p> <strong>exp1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at <span class="hljs-string">&#x27;8&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 A 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>exp2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：intersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//我的解法：暴力法，直接将所有地址存下来，然后倒序查找（其实可以直接用哈希查找会快一点）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        vector&lt;ListNode *&gt; tempa;<br>        vector&lt;ListNode *&gt; tempb;<br>        ListNode* a=headA;<br>        ListNode* b=headB;<br>        <span class="hljs-keyword">while</span>(a!=<span class="hljs-literal">NULL</span>)&#123;<br>            tempa.<span class="hljs-built_in">push_back</span>(a);<br>            a=a-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b!=<span class="hljs-literal">NULL</span>)&#123;<br>            tempb.<span class="hljs-built_in">push_back</span>(b);<br>            b=b-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> num_a=tempa.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> num_b=tempb.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(num_a&gt;=<span class="hljs-number">0</span>&amp;&amp;num_b&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tempa[num_a]==tempb[num_b])&#123;<br>                num_a--;<br>                num_b--;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num_a==tempa.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> tempa[num_a+<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">44</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">41.48</span>%的用户<br>内存消耗：<span class="hljs-number">16.4</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">20.78</span>%的用户<br></code></pre></td></tr></table></figure><p><strong>参考答案：</strong></p><p><img src="https://pic.leetcode-cn.com/1615224578-lFxRVR-Picture2.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-atzfoi-Picture3.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-QvNyxe-Picture4.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-zPMkyB-Picture5.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-MRfzKN-Picture6.png"><img src="https://pic.leetcode-cn.com/1615224578-UIHyvx-Picture7.png"><img src="https://pic.leetcode-cn.com/1615224578-fyOdzW-Picture8.png"></p><p><img src="https://pic.leetcode-cn.com/1615224578-LcVJxI-Picture9.png"></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参考答案：快慢表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA==<span class="hljs-literal">nullptr</span> || headB==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode *a=headA;<br>        ListNode *b=headB;<br>        <span class="hljs-keyword">while</span>(a!=b)&#123;<br>            a=a==<span class="hljs-literal">nullptr</span>?headB:a-&gt;next;<br>            b=b==<span class="hljs-literal">nullptr</span>?headA:b-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>exp:</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解法：暴力堆栈（伪）</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* p=head;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            temp.push_back(p-&gt;val);<br>            p=p-&gt;next;<br>            i++;<br>        &#125;<br>        p=head;<br>        i--;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            p-&gt;val=temp[i--];<br>            p=p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//我的解法二：反转指针</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* ptr=head;<br>        ListNode* p=head-&gt;next;<br>        ptr-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            ListNode* rear=p-&gt;next;<br>            p-&gt;next=ptr;<br>            ptr=p;<br>            p=rear;<br>        &#125;<br>        p-&gt;next=ptr;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">4</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">96.18</span>%的用户<br>内存消耗：<span class="hljs-number">8.2</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">24.63</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">8</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">49.54</span>%的用户<br>内存消耗：<span class="hljs-number">8.1</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">45.94</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//答案方法：优化版解法二</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode* curr = head;<br>        <span class="hljs-keyword">while</span> (curr) &#123;<br>            ListNode* next = curr-&gt;next;<br>            curr-&gt;next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列&amp;栈"></a><strong>队列&amp;栈</strong></h1><h2 id="20-有效的括号（栈-字符串的处理）"><a href="#20-有效的括号（栈-字符串的处理）" class="headerlink" title="20. 有效的括号（栈/字符串的处理）"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a>（栈/字符串的处理）</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：s = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br>    <br>输入：s = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br><br>输入：s = <span class="hljs-string">&quot;([)]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的解法：栈（其实也想不到其他的解法）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>)<br>                temp.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>()&amp;&amp;temp.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    temp.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>()&amp;&amp;temp.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                    temp.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>()&amp;&amp;temp.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                    temp.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">s.empty();         <span class="hljs-comment">//如果栈为空则返回true, 否则返回false;</span><br>s.size();          <span class="hljs-comment">//返回栈中元素的个数</span><br>s.top();           <span class="hljs-comment">//返回栈顶元素, 但不删除该元素</span><br>s.pop();           <span class="hljs-comment">//弹出栈顶元素, 但不返回其值</span><br>s.push();          <span class="hljs-comment">//将元素压入栈顶</span><br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;      <span class="hljs-comment">//声明一个栈</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string s=<span class="hljs-string">&quot;helloWorld&quot;</span>;        <span class="hljs-comment">//逐个读取字符串字符</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[i]);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">0</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">100.00</span>%的用户<br>内存消耗：<span class="hljs-number">6.1</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">73.63</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//大佬的解法：利用ascii码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;&quot;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        vector&lt;<span class="hljs-keyword">char</span>&gt; stack;<br>        stack.<span class="hljs-built_in">push_back</span>(s[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>() == <span class="hljs-literal">true</span>)&#123;<br>                stack.<span class="hljs-built_in">push_back</span>(s[i]);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] - stack.<span class="hljs-built_in">back</span>() == <span class="hljs-number">1</span> || s[i] - stack.<span class="hljs-built_in">back</span>() == <span class="hljs-number">2</span>)&#123;<br>                stack.<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push_back</span>(s[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], l2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这里用的就是正常的归并，就不再赘述了</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* head=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* curr=head;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-literal">nullptr</span>&amp;&amp;list2!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123;<br>                curr-&gt;next=list1;<br>                list1=list1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                curr-&gt;next=list2;<br>                list2=list2-&gt;next;<br>            &#125;<br>            curr=curr-&gt;next;<br>        &#125;<br>        curr-&gt;next=list1==<span class="hljs-literal">nullptr</span>?list2:list1;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">4</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">92.47</span>%的用户<br>内存消耗：<span class="hljs-number">14.4</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">43.43</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参考答案：递归</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1, l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> <strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：heights = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参考答案：单调栈</span><br><span class="hljs-comment">//详见https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;heights)</span> </span>&#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size = heights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;                                                    <span class="hljs-comment">//从左向右遍历</span><br>            <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[stk.<span class="hljs-built_in">top</span>()] &gt; heights[i]) &#123;                       <span class="hljs-comment">//当出现一个严格小于栈内的height时</span><br>                <span class="hljs-keyword">int</span> length = heights[stk.<span class="hljs-built_in">top</span>()];                                            <span class="hljs-comment">//退栈，同时计算矩形宽度</span><br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">int</span> weight = i;<br>                <span class="hljs-keyword">if</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>                    weight = i - stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, length * weight);<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);                                                                      <span class="hljs-comment">//压栈</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> length = heights[stk.<span class="hljs-built_in">top</span>()];<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">int</span> weight = size;<br>            <span class="hljs-keyword">if</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>                weight = size - stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, length * weight);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a></h2><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>exp:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg"></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><p>参考答案：（单调栈）</p><p><img src="https://pic.leetcode-cn.com/aabb1b287134cf950aa80526806ef4025e3920d57d237c0369ed34fae83e2690-image.png"></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix[<span class="hljs-number">0</span>].length];<br>    <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; matrix.length; row++) &#123;<br>        <span class="hljs-comment">//遍历每一列，更新高度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; matrix[<span class="hljs-number">0</span>].length; col++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                heights[col] += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                heights[col] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//调用上一题的解法，更新函数</span><br>        maxArea = Math.<span class="hljs-built_in">max</span>(maxArea, <span class="hljs-built_in">largestRectangleArea</span>(heights));<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxArea;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p &lt; heights.length) &#123;<br>        <span class="hljs-comment">//栈空入栈</span><br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            stack.<span class="hljs-built_in">push</span>(p);<br>            p++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> top = stack.<span class="hljs-built_in">peek</span>();<br>            <span class="hljs-comment">//当前高度大于栈顶，入栈</span><br>            <span class="hljs-keyword">if</span> (heights[p] &gt;= heights[top]) &#123;<br>                stack.<span class="hljs-built_in">push</span>(p);<br>                p++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//保存栈顶高度</span><br>                <span class="hljs-keyword">int</span> height = heights[stack.<span class="hljs-built_in">pop</span>()];<br>                <span class="hljs-comment">//左边第一个小于当前柱子的下标</span><br>                <span class="hljs-keyword">int</span> leftLessMin = stack.<span class="hljs-built_in">isEmpty</span>() ? <span class="hljs-number">-1</span> : stack.<span class="hljs-built_in">peek</span>();<br>                <span class="hljs-comment">//右边第一个小于当前柱子的下标</span><br>                <span class="hljs-keyword">int</span> RightLessMin = p;<br>                <span class="hljs-comment">//计算面积</span><br>                <span class="hljs-keyword">int</span> area = (RightLessMin - leftLessMin - <span class="hljs-number">1</span>) * height;<br>                maxArea = Math.<span class="hljs-built_in">max</span>(area, maxArea);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-comment">//保存栈顶高度</span><br>        <span class="hljs-keyword">int</span> height = heights[stack.<span class="hljs-built_in">pop</span>()];<br>        <span class="hljs-comment">//左边第一个小于当前柱子的下标</span><br>        <span class="hljs-keyword">int</span> leftLessMin = stack.<span class="hljs-built_in">isEmpty</span>() ? <span class="hljs-number">-1</span> : stack.<span class="hljs-built_in">peek</span>();<br>        <span class="hljs-comment">//右边没有小于当前高度的柱子，所以赋值为数组的长度便于计算</span><br>        <span class="hljs-keyword">int</span> RightLessMin = heights.length;<br>        <span class="hljs-keyword">int</span> area = (RightLessMin - leftLessMin - <span class="hljs-number">1</span>) * height;<br>        maxArea = Math.<span class="hljs-built_in">max</span>(area, maxArea);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxArea;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li>MinStack() 初始化堆栈对象。</li><li>void push(int val) 将元素val推入堆栈。</li><li>void pop() 删除堆栈顶部的元素。</li><li>int top() 获取堆栈顶部的元素。</li><li>int getMin() 获取堆栈中的最小元素。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br>MinStack minStack = <span class="hljs-keyword">new</span> MinStack();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//我的解法：哨兵</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-keyword">int</span> val;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinStack</span>* <span class="hljs-title">next</span>;</span><br>&#125; MinStack;<br><br><br><span class="hljs-function">MinStack* <span class="hljs-title">minStackCreate</span><span class="hljs-params">()</span> </span>&#123;<br>    MinStack* head=(MinStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(MinStack));<br>    head-&gt;val=<span class="hljs-number">12138</span>;<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">minStackPush</span><span class="hljs-params">(MinStack* obj, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    MinStack* q=obj;<br>    MinStack* p=(MinStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(MinStack));<br>    p-&gt;val=val;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(q-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        q=q-&gt;next;<br>    &#125;<br>    q-&gt;next=p;<br>    <span class="hljs-keyword">if</span>(obj-&gt;val==<span class="hljs-number">12138</span>)&#123;<br>        obj-&gt;val=val;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(obj-&gt;val&gt;val)&#123;<br>        obj-&gt;val=val;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">minStackPop</span><span class="hljs-params">(MinStack* obj)</span> </span>&#123;<br>    MinStack* p=obj;<br>    MinStack* before;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        before=p;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num=p-&gt;val;<br>    <span class="hljs-built_in">free</span>(p);<br>    before-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(num==obj-&gt;val)&#123;<br>        MinStack* q=obj-&gt;next;<br>        obj-&gt;val=<span class="hljs-number">12138</span>;<br>        <span class="hljs-keyword">if</span>(q!=<span class="hljs-literal">NULL</span>)&#123;<br>            obj-&gt;val=q-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(q-&gt;val&lt;obj-&gt;val)&#123;<br>                obj-&gt;val=q-&gt;val;<br>            &#125;<br>            q=q-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minStackTop</span><span class="hljs-params">(MinStack* obj)</span> </span>&#123;<br>    MinStack* q=obj-&gt;next;<br>    <span class="hljs-keyword">if</span>(q==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        q=q-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q-&gt;val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minStackGetMin</span><span class="hljs-params">(MinStack* obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(obj-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj-&gt;val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">minStackFree</span><span class="hljs-params">(MinStack* obj)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(obj);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack struct will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = minStackCreate();</span><br><span class="hljs-comment"> * minStackPush(obj, val);</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * minStackPop(obj);</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * int param_3 = minStackTop(obj);</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * int param_4 = minStackGetMin(obj);</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * minStackFree(obj);</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">136</span> ms, 在所有 C 提交中击败了<span class="hljs-number">33.06</span>%的用户<br>内存消耗：<span class="hljs-number">12.8</span> MB, 在所有 C 提交中击败了<span class="hljs-number">67.69</span>%的用户<br></code></pre></td></tr></table></figure><p><strong>参考答案：</strong></p><p>可以用一个栈，这个栈同时保存的是每个数字 x 进栈的时候的值 与 插入该值后的栈内最小值。即每次新元素 x 入栈的时候保存一个元组：（当前值 x，栈内最小值）。</p><p>这个元组是一个整体，同时进栈和出栈。即栈顶同时有值和栈内最小值，top()函数是获取栈顶的当前值，即栈顶元组的第一个值； getMin() 函数是获取栈内最小值，即栈顶元组的第二个值；pop() 函数时删除栈顶的元组。</p><p>每次新元素入栈时，要求新的栈内最小值：比较当前新插入元素 x 和 当前栈内最小值（即栈顶元组的第二个值）的大小。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;x, x&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;x, <span class="hljs-built_in">min</span>(x, st.<span class="hljs-built_in">top</span>().second)&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().first;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().second;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; st;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p><strong>示例 1：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[<span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>] <span class="hljs-number">-3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span> [<span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>] <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span> [<span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>  <span class="hljs-number">5</span>] <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span> [<span class="hljs-number">-3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>] <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span> [<span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>] <span class="hljs-number">7</span>       <span class="hljs-number">6</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">-1</span>  <span class="hljs-number">-3</span>  <span class="hljs-number">5</span> [<span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]      <span class="hljs-number">7</span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的解答：首次遍历最大值，之后若最大值退出窗口，则重新遍历求最值，</span><br><span class="hljs-comment">//否则已知最大值和推入窗口的值比较</span><br><span class="hljs-comment">//结果：超时</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-keyword">int</span> num=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> maxPosition = <span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>()+k);<br>        temp.<span class="hljs-built_in">push_back</span>(*maxPosition);<br>        <span class="hljs-keyword">int</span> curr=*maxPosition;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k;i&lt;num;i++)&#123;<br>            <span class="hljs-keyword">if</span>(curr==temp[i-k])&#123;<br>                maxPosition = <span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>()+i-k+<span class="hljs-number">1</span>, nums.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">push_back</span>(*maxPosition);<br>                curr=*maxPosition;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(temp[i]&gt;curr)&#123;<br>                    temp.<span class="hljs-built_in">push_back</span>(temp[i]);<br>                    curr=temp[i];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    temp.<span class="hljs-built_in">push_back</span>(curr);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/">参考答案</a>：</p><p>遍历数组，将 数 存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//使用双向队列。</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        deque&lt;<span class="hljs-keyword">int</span>&gt; dq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">//窗口尾部超过了k，则将最左边的元素移除</span><br>            <span class="hljs-comment">//依据性质，窗口下标一定是按照时间顺序向前的</span><br>            <span class="hljs-keyword">if</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() == i - k) dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-comment">//从后往前移除所有队列中小于当前元素的元素</span><br>            <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[dq.<span class="hljs-built_in">back</span>()])&#123;<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            <span class="hljs-comment">//在队列中添加当前元素</span><br>            dq.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//窗口第一次到达k，则在结果中插入最大值(deque最前面的元素)</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k<span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">208</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">84.11</span>%的用户<br>内存消耗：<span class="hljs-number">131.5</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">31.15</span>%的用户<br></code></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：s = <span class="hljs-string">&quot;3[a]2[bc]&quot;</span><br>输出：<span class="hljs-string">&quot;aaabcbc&quot;</span><br><br>输入：s = <span class="hljs-string">&quot;3[a2[c]]&quot;</span><br>输出：<span class="hljs-string">&quot;accaccacc&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参考答案：栈（毫无疑问）</span><br><span class="hljs-comment">//为啥字符串就那么难弄呢？:(</span><br><span class="hljs-comment">//思路大概都能想得到，但是到实操一大堆问题</span><br><span class="hljs-comment">//思路：1.可以直接用&lt;string&gt;不用&lt;char&gt;那种垃圾</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        stack &lt;<span class="hljs-keyword">int</span>&gt; nums;<br>        stack &lt;string&gt; strs;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++ i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>            &#123;<br>                num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) ||(s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>))<br>            &#123;<br>                res = res + s[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-comment">//将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内</span><br>            &#123;<br>                nums.<span class="hljs-built_in">push</span>(num);<br>                num = <span class="hljs-number">0</span>;<br>                strs.<span class="hljs-built_in">push</span>(res); <br>                res = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> times = nums.<span class="hljs-built_in">top</span>();<br>                nums.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; times; ++ j)<br>                    strs.<span class="hljs-built_in">top</span>() += res;<br>                res = strs.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//之后若还是字母，就会直接加到res之后，因为它们是同一级的运算</span><br>                                  <span class="hljs-comment">//若是左括号，res会被压入strs栈，作为上一层的运算</span><br>                strs.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//我的重写：报错（这道题是真的难解）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; times;<br>        stack&lt;string&gt; st;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>        string temp=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>||s[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>                temp+=s[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                j++;<br>                st.<span class="hljs-built_in">push</span>(temp);<br>                temp=<span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                <span class="hljs-keyword">int</span> int1=<span class="hljs-built_in">stoi</span>(&amp;s[i-j]);<br>                j=<span class="hljs-number">0</span>;<br>                times.<span class="hljs-built_in">push</span>(int1);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                <span class="hljs-keyword">int</span> t=times.<span class="hljs-built_in">top</span>();<br>                string q=<span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;t;k++)&#123;<br>                    st.<span class="hljs-built_in">top</span>()+=temp;<br>                &#125;<br>                temp=st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                times.<span class="hljs-built_in">pop</span>();<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入: temperatures = [<span class="hljs-number">73</span>,<span class="hljs-number">74</span>,<span class="hljs-number">75</span>,<span class="hljs-number">71</span>,<span class="hljs-number">69</span>,<span class="hljs-number">72</span>,<span class="hljs-number">76</span>,<span class="hljs-number">73</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>输入: temperatures = [<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br><br>输入: temperatures = [<span class="hljs-number">30</span>,<span class="hljs-number">60</span>,<span class="hljs-number">90</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的方法：队列</span><br><span class="hljs-comment">//先将所有元素的result置零</span><br><span class="hljs-comment">//创建一个队列，每次取一个tempture跟队头比较，若队头元素小于tempture则退队</span><br><span class="hljs-comment">//同时记录时间差值录入result</span><br><span class="hljs-comment">//依次进行，直到找到比它大的元素，将tempture加入队头</span><br><span class="hljs-comment">//参考答案和我的解法差不多，在此就不多做展示了</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        result.<span class="hljs-built_in">resize</span>(temperatures.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-built_in">fill</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        deque&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; temp;<br>        temp.<span class="hljs-built_in">push_front</span>(&#123;<span class="hljs-number">0</span>,temperatures[<span class="hljs-number">0</span>]&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;temperatures.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i]&gt;temp.<span class="hljs-built_in">front</span>().second)&#123;<br>                result[temp.<span class="hljs-built_in">front</span>().first]=i-temp.<span class="hljs-built_in">front</span>().first;<br>                temp.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            temp.<span class="hljs-built_in">push_front</span>(&#123;i,temperatures[i]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">执行用时：<span class="hljs-number">128</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">84.33</span>%的用户<br>内存消耗：<span class="hljs-number">90.9</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">5.04</span>%的用户<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入: s = <span class="hljs-string">&quot;abcabcbb&quot;</span><br>输出: <span class="hljs-number">3</span> <br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;abc&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br><br>输入: s = <span class="hljs-string">&quot;bbbbb&quot;</span><br>输出: <span class="hljs-number">1</span><br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;b&quot;</span>，所以其长度为 <span class="hljs-number">1</span>。<br><br>输入: s = <span class="hljs-string">&quot;pwwkew&quot;</span><br>输出: <span class="hljs-number">3</span><br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;wke&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的方法：deququ滑动窗口+哈希查询</span><br><span class="hljs-comment">//注：如果不用pair而是直接记录最后用size（）记录大小也可以，但是时间会下降</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        deque&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; signal;<br>        <span class="hljs-keyword">int</span> max=<span class="hljs-number">1</span>;<br>        signal.<span class="hljs-built_in">resize</span>(<span class="hljs-number">300</span>);<br>        <span class="hljs-built_in">fill</span>(signal.<span class="hljs-built_in">begin</span>(),signal.<span class="hljs-built_in">end</span>(),<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">int</span> ss=(<span class="hljs-keyword">int</span>)s[i];<br>            <span class="hljs-keyword">if</span>(signal[ss]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">int</span> k=temp.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">if</span>(k&gt;max)&#123;<br>                    max=k;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>() &amp;&amp; temp.<span class="hljs-built_in">front</span>()!=ss)&#123;<br>                    signal[temp.<span class="hljs-built_in">front</span>()]=<span class="hljs-number">-1</span>;<br>                    temp.<span class="hljs-built_in">pop_front</span>();<br>                &#125;<br>                temp.<span class="hljs-built_in">pop_front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(ss);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                signal[ss]=<span class="hljs-number">1</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(ss);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> k=temp.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(k&gt;max)&#123;<br>            max=k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//答案：滑动窗口（比我的简单）</span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">执行用时：<span class="hljs-number">4</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">97.40</span>%的用户<br>内存消耗：<span class="hljs-number">9.3</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">49.54</span>%的用户<br></code></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><strong>哈希表</strong></h1><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h2><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br><br>输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;&quot;</span>]]<br><br>输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;a&quot;</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//网友解法：用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。其余步骤就是用map存储，和别人的一致了。</span><br><span class="hljs-comment">//我没复现出来，新方法太多了:(</span><br><span class="hljs-comment">//auto：</span><br><span class="hljs-comment">//map:</span><br><span class="hljs-comment">//str:strs</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        map&lt;<span class="hljs-keyword">double</span>,vector&lt;string&gt;&gt; cmap;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">double</span> code[<span class="hljs-number">26</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">37</span>,<span class="hljs-number">41</span>,<span class="hljs-number">43</span>,<span class="hljs-number">47</span>,<span class="hljs-number">53</span>,<span class="hljs-number">59</span>,<span class="hljs-number">61</span>,<span class="hljs-number">67</span>,<span class="hljs-number">71</span>,<span class="hljs-number">73</span>,<span class="hljs-number">79</span>,<span class="hljs-number">83</span>,<span class="hljs-number">89</span>,<span class="hljs-number">97</span>,<span class="hljs-number">101</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str:strs)&#123;<br>            <span class="hljs-keyword">double</span> sum=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:str) &#123;<br>                sum*=code[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cmap[sum].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> vs:cmap)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(vs.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>exp:</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">输入：nums = [<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">200</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]。它的长度为 <span class="hljs-number">4</span>。<br><br>输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的解法：排序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> max=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> temp=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+<span class="hljs-number">1</span>==nums[i+<span class="hljs-number">1</span>])&#123;<br>                temp++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]==nums[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(temp&gt;max)&#123;<br>                    max=temp;<br>                &#125;<br>                temp=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp&gt;max)&#123;<br>            max=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">执行用时：<span class="hljs-number">56</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">81.50</span>%的用户<br>内存消耗：<span class="hljs-number">33</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">22.82</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参考答案：哈希表</span><br><span class="hljs-comment">//先把所有的数值扔进哈希表中</span><br><span class="hljs-comment">//然后开始遍历哈希表</span><br><span class="hljs-comment">//对于哈希表中任意一个数值i，如果i-1不存在（不存在相邻并且比它小的数字），则进行下一步</span><br><span class="hljs-comment">//统计每一个相邻并且比它大的数字，更新数值</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; num_set;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; num : nums) &#123;<br>            num_set.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> longestStreak = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; num : num_set) &#123;<br>            <span class="hljs-keyword">if</span> (!num_set.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">int</span> currentNum = num;<br>                <span class="hljs-keyword">int</span> currentStreak = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span> (num_set.<span class="hljs-built_in">count</span>(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                    currentNum += <span class="hljs-number">1</span>;<br>                    currentStreak += <span class="hljs-number">1</span>;<br>                &#125;<br><br>                longestStreak = <span class="hljs-built_in">max</span>(longestStreak, currentStreak);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> longestStreak;           <br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//我的复现：</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; num_set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            num_set.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; num:num_set)&#123;   <span class="hljs-comment">//为什么要用const int&amp; ?</span><br>            <span class="hljs-keyword">if</span>(num_set.<span class="hljs-built_in">count</span>(num<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">int</span> curr=num;<br>                <span class="hljs-keyword">int</span> count=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(num_set.<span class="hljs-built_in">count</span>(curr+<span class="hljs-number">1</span>))&#123;<br>                    curr++;<br>                    count++;<br>                &#125;<br>                result=result&lt;count?count:result;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;           <br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//for(const int&amp; num:num_set)&#123;&#125;</span><br><span class="hljs-comment">//for (auto iter = uset.begin(); iter != uset.end(); ++iter) &#123;</span><br><span class="hljs-comment">//cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>exp:</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], <span class="hljs-attr">pos</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的解法：哈希表（用快慢表也可以）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode*&gt; set;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">count</span>(head))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                set.<span class="hljs-built_in">insert</span>(head);<br>                head=head-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">执行用时：16</span> <span class="hljs-comment">ms</span><span class="hljs-string">,</span> <span class="hljs-comment">在所有</span> <span class="hljs-comment">C</span>++ <span class="hljs-comment">提交中击败了23</span><span class="hljs-string">.</span><span class="hljs-comment">55%的用户</span><br><span class="hljs-comment">内存消耗：10</span><span class="hljs-string">.</span><span class="hljs-comment">2</span> <span class="hljs-comment">MB</span><span class="hljs-string">,</span> <span class="hljs-comment">在所有</span> <span class="hljs-comment">C</span>++ <span class="hljs-comment">提交中击败了21</span><span class="hljs-string">.</span><span class="hljs-comment">41%的用户</span><br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//哈希表，结果错误</span><br><span class="hljs-comment">//草，今天才知道unordered_set的insert根本没法计数，何必去设计count函数误导人</span><br><span class="hljs-comment">//count函数直接设计成isEmpty不就行了</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; set;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<br>        set.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum+=nums[i];<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">count</span>(sum-k)!=<span class="hljs-number">0</span>)&#123;<br>                result+=set.<span class="hljs-built_in">count</span>(sum-k);<br>            &#125;<br>            set.<span class="hljs-built_in">insert</span>(sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的解法：递归</span><br><span class="hljs-comment">//为什么使用vector&lt;int&gt;&amp; temp（引用类型）？详见下面</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp,TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">trans</span>(temp,root-&gt;left);<br>            temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">trans</span>(temp,root-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-built_in">trans</span>(temp,root);<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="引用与指针-主要是引用"><a href="#引用与指针-主要是引用" class="headerlink" title="引用与指针(主要是引用)"></a>引用与指针(主要是引用)</h3><blockquote><ul><li><p>指针：是一个变量，存储的是一个地址，指向内存的一个存储单元；</p></li><li><p>引用：是原变量的一个别名，跟原来的变量实质上是同一个东西.</p></li></ul><p>以下示例程序中，k 被初始化为i的引用。语句 k = j 并不能将 k 修改成为j的引用，只是把k的值改变成为 6。由于 k 是 i 的引用，所以i的值也变成了 6。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>; <br><span class="hljs-keyword">int</span> j = <span class="hljs-number">6</span>; <br><span class="hljs-keyword">int</span> &amp;k = i; <br>k = j; <span class="hljs-comment">// k 和 i 的值都变成了 6;</span><br></code></pre></td></tr></table></figure><p>引用的规则：</p><ul><li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li><li>不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。</li><li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li></ul><p>C++ 语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span><br><span class="hljs-function"></span>&#123; <br>    x = x + <span class="hljs-number">10</span>; <br>&#125; <br>... <br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; <br>Func1(n); <br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// n = 0 </span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//由于 Func2 函数体内的 x 是指向外部变量 n 的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span> </span><br><span class="hljs-function"></span>&#123; <br>    (* x) = (* x) + <span class="hljs-number">10</span>; <br>&#125; <br>... <br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; <br>Func2(&amp;n); <br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// n = 10 </span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span> </span><br><span class="hljs-function"></span>&#123; <br>    x = x + <span class="hljs-number">10</span>; <br>&#125; <br>... <br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; <br>Func3(n); <br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// n = 10</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//参考答案：递归</span><br><span class="hljs-comment">//自己实在记不得怎么弄了。。。参考了答案自己重写了一个</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(TreeNode* p,TreeNode* q)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!p&amp;&amp;!q)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!p||!q)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> p-&gt;val==q-&gt;val &amp;&amp; <span class="hljs-built_in">cmp</span>(p-&gt;left,q-&gt;right) &amp;&amp; <span class="hljs-built_in">cmp</span>(p-&gt;right,q-&gt;left);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">cmp</span>(root,root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p> <img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"></p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//我的解法：层序遍历+头尾指针</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        deque&lt;TreeNode*&gt; p;<br>        p.<span class="hljs-built_in">push_back</span>(root);<br>        TreeNode* top=root;<br>        TreeNode* rear=root;<br>        <span class="hljs-keyword">while</span>(!p.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* q=p.<span class="hljs-built_in">front</span>();<br>            temp.<span class="hljs-built_in">push_back</span>(q-&gt;val);<br>            p.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">if</span>(q-&gt;left)&#123;<br>                p.<span class="hljs-built_in">push_back</span>(q-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(q-&gt;right)&#123;<br>                p.<span class="hljs-built_in">push_back</span>(q-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(q==rear)&#123;<br>                rear=p.<span class="hljs-built_in">back</span>();<br>                top=p.<span class="hljs-built_in">front</span>();<br>                result.<span class="hljs-built_in">push_back</span>(temp);<br>                temp.<span class="hljs-built_in">clear</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">执行用时：<span class="hljs-number">8</span> ms, 在所有 C++ 提交中击败了<span class="hljs-number">23.02</span>%的用户<br>内存消耗：<span class="hljs-number">12.1</span> MB, 在所有 C++ 提交中击败了<span class="hljs-number">76.63</span>%的用户<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//网友解法：先序遍历（递归），每次直接push</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">pre</span>(root, <span class="hljs-number">0</span>, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> depth, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (depth &gt;= ans.<span class="hljs-built_in">size</span>())<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt; &#123;&#125;);<span class="hljs-comment">//说明这一层还没来过，这是第一次来，所以得扩容</span><br>        ans[depth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">pre</span>(root-&gt;left, depth + <span class="hljs-number">1</span>, ans);<br>        <span class="hljs-built_in">pre</span>(root-&gt;right, depth + <span class="hljs-number">1</span>, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOTE:Linear_Algebra</title>
      <link href="/2022/03/07/linear-algebra/"/>
      <url>/2022/03/07/linear-algebra/</url>
      
        <content type="html"><![CDATA[<p>这是一份关于MIT 18.06的线性代数笔记，同时包含配套英文教材《introduction to linear algebra》，这份笔记记载了从第三章到最后一章的内容<span id="more"></span></p><h1 id="MIT-18-06-Linear-Algebra"><a href="#MIT-18-06-Linear-Algebra" class="headerlink" title="MIT 18.06 Linear Algebra"></a>MIT 18.06 Linear Algebra</h1><p>不同于国内教材，这门课程</p><ul><li>基本完全依赖于向量以及向量空间</li><li>除了练习题之外，几乎没有严谨的定理和相关推论的推导</li><li>本书更加注重应用部分（介绍了马尔可夫矩阵，小波矩阵，傅里叶快速转化矩阵，复数矩阵和 matrix matriese（我不知道怎么翻译这个））</li><li>章节次序与以往的教材不同：<br>解线性方程 -&gt; 向量空间 -&gt; 正交性 -&gt; 行列式 -&gt; 特征值与特征向量 -&gt; 线性转换 -&gt; 应用</li></ul><p>笔记参照课程MIT 18.06记录，配套教材为《introduction to linear algebra》，国内由清华大学出版社出版影印版，目前无中文版。</p><div class="bvideo">    <a href="//www.bilibili.com/video/BV1ix411f7Yp" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/62f0e3f092f7b98b9968b237aec9bb706bb958d2.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">27:55:09</span>            </div>            <div class="bvideo-info">                <p class="title">【完整版-麻省理工-线性代数】全34讲+配套教材</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>160.4万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>2.3万</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">小风哥_ANGEL</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><p><img src="https://kawasaki12138.github.io/img/4.jpg" alt="avatar"></p><p><a href="https://kawasaki12138.github.io/pdf/LinearAlgebra-MEMEME.pdf">点击下载笔记</a></p><p><a href="https://kawasaki12138.github.io/pdf/Introduction_to_Linear_Algebra.pdf">点击下载配套教材</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> Linear algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIB:一杯苦酒</title>
      <link href="/2022/01/22/Yi/"/>
      <url>/2022/01/22/Yi/</url>
      
        <content type="html"><![CDATA[<p>雅科夫列夫曾任苏共中央宣传部长、政治局委员和总统顾问等重要职务，被认为是戈尔巴乔夫时期改革的倡导者，是苏联“公开化”运动的奠墓人。在本书中，作者从俄罗斯布尔什维主义的产生与发展讲起，剖析了布尔什维主义对苏联各个历史时期政治与社会生活的影响和作用。作者认为，在苏联经历了大清洗、第二次世界大战、冷战等各个历史时期之后，放弃人洞的革命理论，走改良这路，是惟一正确的发展道路。作者还认为，简单地导入不适合国情的西方民主制，给今天的俄罗斯带来了官僚主义盛行、国力不下降一系列恶果。 </p><p>作者表明，强大的俄罗斯不是靠军事实力获得的，它需要凭人民的美德和生活的质量来赢取。只有在法律至上并重视人的价值的条件下，俄罗斯才能走上正途。<span id="more"></span></p><h2 id="一怀苦酒——俄罗斯的布尔什维主义和改革运动"><a href="#一怀苦酒——俄罗斯的布尔什维主义和改革运动" class="headerlink" title="一怀苦酒——俄罗斯的布尔什维主义和改革运动"></a>一怀苦酒——俄罗斯的布尔什维主义和改革运动</h2><div class="row">    <embed src="https://kawasaki12138.github.io/pdf/Yi.pdf" width="100%" height="550" type="application/pdf"></div><p><a href="https://kawasaki12138.github.io/pdf/Yi.pdf">点击下载</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> CCCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analysis</title>
      <link href="/2021/07/16/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/"/>
      <url>/2021/07/16/%E9%99%B6%E5%93%B2%E8%BD%A9%E5%AE%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这是依照陶哲轩的《陶哲轩实分析》所记录的一份笔记。因为内容太多，现在先停更一段时间，有空再更。<span id="more"></span></p><h2 id="第二章-自然数-N"><a href="#第二章-自然数-N" class="headerlink" title="第二章   自然数 N"></a>第二章   自然数 N</h2><h3 id="2-1-皮亚诺定理"><a href="#2-1-皮亚诺定理" class="headerlink" title="2.1 皮亚诺定理"></a>2.1 皮亚诺定理</h3><h4 id="1-皮亚诺定理"><a href="#1-皮亚诺定理" class="headerlink" title="1. 皮亚诺定理"></a>1. 皮亚诺定理</h4><hr><p>​    <strong>自然数</strong>是集合</p><p>​                            N：={0，1，2，3…..}</p><p>​    的元素，其中，集合N是由0开始，无休止地往前进行计数所得到的所有元素构成的集合。我们称N为<strong>自然数集</strong></p><hr><p>​    虽然这个定理看起来显而易见，但是在这里我们并没有指明什么是计数，计数是否存在返回（即4=0）的现象，因此，我们对此定理进行规范化，并提出了五个公理，即</p><ul><li>0是一个自然数</li><li>如果n是自然数，那么n++也是一个自然数（在此基础上我们定义1：=0++）</li><li>0不是任何自然数的后继</li><li>若n！= m，则n++ != m++</li><li>令P(n)为自然数的某性质，若P(0)为真且P(n)为真时P(n++)为真，那么对于任一自然数n，P(n)一定为真。</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Planning in Summer Vacation</title>
      <link href="/2021/07/15/Planning-in-Summer-Vacation/"/>
      <url>/2021/07/15/Planning-in-Summer-Vacation/</url>
      
        <content type="html"><![CDATA[<p>​    这是2021年暑假的学习计划以及需要完成的目标，让我们看一下自己立下的FLAG能实现多少吧<span id="more"></span></p><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><ul><li>陶哲轩实分析     19章（已完成前4章）</li><li>数学建模             13章</li></ul><h2 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h2><ul><li>N5,N4单词        20单元</li><li>N3单词              20单元</li><li>N3语法              若干</li></ul><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><ul><li>learning from data         5章</li><li>javascript, html,  css       若干</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h3><ul><li>实分析完成至4.3</li><li>N5完成第3单元</li><li>DATA完成至1.3</li></ul><h3 id="8-04"><a href="#8-04" class="headerlink" title="8.04"></a>8.04</h3><ul><li>实分析 至第8章</li><li>N5完成</li><li>完成srdp框架制定</li><li>DATA完成至1.3</li></ul><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/05/hello-world/"/>
      <url>/2021/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Amor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.<span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
